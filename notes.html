<!DOCTYPE html>
<html lang="pl">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Aleksander Krysa - WTF notes</title>
    <link href="styles.css" rel="stylesheet" type="text/css" />
  </head>

  <body class="body">
    <header class="hero" id="hero">
      <span class="hero__title-1">Aleksander Krysa </span>
      <span class="hero__title-2">"błądząc w krainie frontendu" </span>
      <span class="hero__description-1">notatki ze szkolenia </span>
      <a class="hero__link" href="https://cotenfrontend.pl/">
        <span class="hero__description-2">WTF </span>
        <span class="hero__description-3">co ten </span>
        <span class="hero__description-4">frontend</span>
      </a>
    </header>

    <nav class="navigation">
      <a href="#hero" class="navigation__link">↑ Powrót na górę ↑</a>
      <a href="library.html" class="navigation__link">Przydatne materiały</a>
      <a href="notes.html" class="navigation__link">Notatki z tygodni</a>
      <a href="index.html" class="navigation__link">O stronie</a>
    </nav>

    <main class="main">
      <header>
        <h1 class="main__heading">Jakich rzeczy udało mi się dowiedzieć?</h1>
      </header>

      <ul class="main__list">
        <li class="main__list__item"><a href="#week1">Tydzień 1</a></li>
        <li class="main__list__item"><a href="#week2">Tydzień 2</a></li>
        <li class="main__list__item"><a href="#week3">Tydzień 3</a></li>
        <li class="main__list__item"><a href="#week4">Tydzień 4</a></li>
        <li class="main__list__item"><a href="#week5">Tydzień 5</a></li>
        <li class="main__list__item"><a href="#week6">Tydzień 6</a></li>
        <li class="main__list__item"><a href="#week7">Tydzień 7</a></li>
        <li class="main__list__item"><a href="#week8">Tydzień 8</a></li>
        <li class="main__list__item"><a href="#week9">Tydzień 9</a></li>
        <li class="main__list__item"><a href="#week10">Tydzień 10</a></li>
        <li class="main__list__item"><a href="#week11">Tydzień 11</a></li>
        <li class="main__list__item"><a href="#week12">Tydzień 12</a></li>
        <li class="main__list__item"><a href="#week13">Tydzień 13</a></li>
      </ul>

      <!-- START OF WEEEK -->
      <section id="week1" class="week anchorOffset">
        <h2 class="week__heading">Tydzień 1:</h2>
        <article class="article">
          <h3 class="article__heading">Absolutnie niczego</h3>
          <p class="article__text">
            Choć to raczej nic dziwnego, z racji, że był to tydzień czysto
            organizacyjny.
          </p>
        </article>
      </section>

      <!-- START OF WEEEK -->
      <section id="week2" class="week anchorOffset">
        <h2 class="week__heading">Tydzień 2:</h2>
        <article class="article">
          <h3 class="article__heading">
            Znaczniki &lt;main&gt;&lt;section&gt;&lt;article&gt;
          </h3>
          <p class="article__text">
            Kiedy tworzyłem swoje pierwsze strony nie używałem ich. Miałem
            okazję je później poznać, ale dopiero wyrabiam nawyk ich używania.
          </p>
          <ul class="list">
            <li class="list__item">
              Artykuł powinien opakowywać taką treść, która wykopiowana ze
              strony sama w sobie (bez niczego zzewnątrz) powinna być
              pojedynczą, zrozumiałą i samodzielną treścią
            </li>
            <li class="list__item">
              Sekcja może zawierać albo wiele artykułów, albo być wydzieloną
              częścią artykułu. Nie musi być zrozumiała samodzielnie. Służy
              raczej do grupowania treści
            </li>
            <li class="list__item">
              Zarówno sekcje i artykuły powinny zaczynać się od nagłówków
            </li>
            <li class="list__item">
              Poziom nagłówka powinien odpowiadać poziomowi zagnieżdżenia
              (liczymy tylko semantyczne znaczniki section/article, divy nic nie
              zmieniają)
            </li>
            <li class="list__item">
              Poza znacznikami MAIN raczej nie powinniśmy mieć sekcji ani
              artykułów oraz znaczników Hx
            </li>
          </ul>
        </article>

        <article class="article">
          <h3 class="article__heading">Validator kodu</h3>
          <p class="article__text">
            Dostępnego pod
            <a href="https://validator.w3.org/nu/#textarea">tym adresem</a>
            validatora kodu nie używałem ani nie widziałem wcześniej. Wydaje się
            fajnym rozwiązaniem.
          </p>
        </article>

        <article class="article">
          <h3 class="article__heading">
            Kończenie szkieletu strony przez ! + TAB
          </h3>
          <p class="article__text">
            Wcześniej nie używałem VSC do pisania stron więc nie znam jeszcze
            wszystkich jego funkcjonalności. Szkielet strony to fajne
            rozwiązanie, choć z racji, że wcześniej używałem VSC do tworzenia
            projektów w django, wymagał ręcznego przestawienia "Language mode"
            na HTML żeby dało się tego użyć.
          </p>
        </article>

        <article class="article--red">
          <h3 class="article__heading">Dodatkowe pytania:</h3>
          <ul class="list">
            <li class="list__item">
              Kiedy używamy znacznika &lt;header&gt; a kiedy nie? Według
              informacji na slajdach, można go użyć zarówno do main, section
              oraz article, jednak w szkoleniu nie został wykorzystany przy
              artykułach. Dlaczego?
              <ul class="list list--green">
                <li class="list__item">
                  Header kiedy mamy bardziej złożony nagłówek niż tylko h1-6
                </li>
              </ul>
            </li>
            <li class="list__item">
              Jaka jest poprawna forma wypisywania tagów HTML jako kodu? Tag
              "XMP" którego użyłem? Zastąpienie &lt; przez &amp;lt; oraz &gt;
              przez &amp;gt;? Jeszcze coś innego?
              <ul class="list list--green">
                <li class="list__item">"xmp to prehistoria :)"</li>
                <li class="list__item">
                  najlepiej używać &amp;lt; i tympodobnych. Dla wygody można
                  użyć
                  <a href="https://mothereff.in/html-entities">konwertera</a>
                  lub
                  <a
                    href="https://marketplace.visualstudio.com/items?itemName=christopherstyles.html-entities"
                    >wtyczki</a
                  >
                  <br />
                </li>
              </ul>
            </li>
          </ul>
        </article>
      </section>

      <!-- START OF WEEEK -->
      <section id="week3" class="week anchorOffset">
        <h2 class="week__heading">Tydzień 3:</h2>
        <article class="article">
          <h3 class="article__heading">Kanban & Trello</h3>
          <p class="article__text">
            Miałem wcześniej do czynienia z tym narzędziem pod kątem organizacji
            zadań długoterminowo.<br />
            Pierwszy raz używam go do monitorowania postępów w małych zadaniach.
          </p>
        </article>

        <article class="article">
          <h3 class="article__heading">
            &lt;b&gt; vs &lt;strong&gt; vs &lt;i&gt; vs &lt;em&gt;
          </h3>
          <p class="article__text">
            Do tej pory moja wiedza kończyłą się na "oba pogrubiają" oraz "oba
            pochylają". Dopiero w trakcie szkolenia (w dużej części nastawionego
            na semantykę) poznałem różnicę tj:<br />
          </p>
          <ul class="list list--green">
            <li class="list__item">
              &lt;b&gt; oraz &lt;i&gt; to znaczniki wykorzystywane wyłącznie do
              ozdabiania tekstu (zmiany jego wyglądu)
            </li>
            <li class="list__item">
              &lt;strong&gt; oraz &lt;em&gt; to znaczniki semantyczne, strong
              podkreśla istotność wyrażenia, em sugeruje, że zwrot może być
              metaforą/ironią.
            </li>
          </ul>
        </article>

        <article class="article">
          <h3 class="article__heading">Przewijanie do danego elementu</h3>
          <p class="article__text">
            Kiedyś używałem, później przestałem, ostatecznie zapomniałem, a
            teraz mi przypomniano =)<br />
            Aby przewinąć stronę należy w odnośniku wpiać &lt;a
            href=&quot;#ID&quot;&gt;Widoczny Teskt&lt;/a&gt;
          </p>
          <p class="article__text">
            Istniał jednak jeden problem przy używaniu elementów ustawionych
            jako position: sticky. (Po przesunieciu elementy były zasłonięte)
            Jednym z obejść problemu było dodanie:
          </p>
          <div class="article__code">
            [ID]::before {<br />
            &emsp;content: '';<br />
            &emsp;display: block;<br />
            &emsp;height: 50px;<br />
            &emsp;margin-top: -50px;<br />
            &emsp;visibility: hidden;<br />
            }
          </div>
        </article>

        <article class="article">
          <h3 class="article__heading">Specyficzność stylów</h3>
          <p class="article__text">
            Ogólna zasada brzmiąca "style o większej specyficzności mają
            priorytet" oraz "ze stylów o równej specyficzności priorytet ma ten
            dodany później"
          </p>
          <p class="article__text">
            Znałem już wcześniej. I nawet mniej-więcej potrafiłem wyczuć które
            odwołanie jest bardziej specyficzne. Niemniej, są przypadki, które
            interpretowałbym inaczej. W ramach szkolenia dopiero poznałem
            właściwą metodę liczenia tej specyficzności (porównywalna do
            medali).
          </p>
          <img
            class="article__image"
            src="images/specificity.png"
            alt="How calculate specificity?"
            height="150"
          />
        </article>

        <article class="article">
          <h3 class="article__heading">Nadawanie nazw</h3>
          <ul class="list">
            <li class="list__item">
              Zalecana metoda nadawania nazw to używanie pojedynczych słów (a
              gdy to niemożliwe to kebab-case).
            </li>
            <li class="list__item">
              Nazwy klas powinny opisywać funkcje elementu na stronę.
            </li>
            <li class="list__item">
              Nazwy klas powinny być w języku angielskim.
            </li>
          </ul>
        </article>

        <article class="article">
          <h3 class="article__heading">Odwołania do elementów w CSS</h3>
          <ul class="list">
            <li class="list__item">
              Do elementów odwołujemy się podając ich nazwę. Na przykład:
              <ul class="list">
                <li class="list__item">
                  <span class="article__small-code">a {...</span> albo
                  <span class="article__small-code">div {...</span>
                </li>
              </ul>
            </li>
            <li class="list__item">
              Do klas odwołujemy się podając ich nazwę po kropce, Na przykład:
              <ul class="list">
                <li class="list__item">
                  <span class="article__small-code">.moja-klasa {...</span> albo
                  <span class="article__small-code">.small-code {...</span>
                </li>
              </ul>
            </li>
            <li class="list__item">
              Do ID odwołujemy się podając ich nazwę po #. Na przykład:
              <ul class="list">
                <li class="list__item">
                  <span class="article__small-code">#moje-id {...</span> albo
                  <span class="article__small-code">#top {...</span>
                </li>
              </ul>
            </li>
            <li class="list__item">
              Do elementu X będącego potomkiem elementu Y odwołujemy się
              oddzielając nazwy spacją:
              <ul class="list">
                <li class="list__item">
                  <span class="article__small-code">Y X {...</span> albo
                  <span class="article__small-code">main article {...</span>
                </li>
              </ul>
            </li>
            <li class="list__item">
              Do elementu o nazwie X zawierającego klasę Y odwołujemy się pisząc
              nazwę elemntu i klasę po kropce
              <ul class="list">
                <li class="list__item">
                  <span class="article__small-code">X.Y {...</span> albo
                  <span class="article__small-code"
                    >article.highlighted {...</span
                  >
                </li>
              </ul>
            </li>
          </ul>
        </article>

        <article class="article">
          <h3 class="article__heading">Pierwszy kontakt z JS</h3>
          <p class="article__text">
            Jako, że wcześniej nie używałem JS to wszystko jest tu dla mnie
            nowe.
          </p>
          <section class="article__subsection">
            <h4 class="article__subsection__heading">Dodawanie skryptów</h4>
            <p class="article__text">
              Skrypty dodajemy bezpośrednio przez zamknięciem znacznika body
              wewnątrz tagu <br />
              <span class="article__small-code"
                >&lt;script&gt;&lt;/script&gt;</span
              >
            </p>
            <p class="article__text">
              Można też odwołać się do zewnętrznego pliku z kodem JS poprzez:
              <br />
              <span class="article__small-code">
                &lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt;
              </span>
            </p>
          </section>
          <section>
            <h4 class="article__subsection__heading">Zmienne i stałe</h4>
            <p class="article__subsection__text">
              Podobnie jak w każdym języku programowania, występują tu zmienne i
              stałe.
            </p>
            <p class="article__subsection__text">
              Zmienne tworzymy przez polecenie <br />
              <span class="article__small-code">let name = 'value'</span>
            </p>
            <p class="article__subsection__text">
              Stałe tworzymy przez polecenie <br />
              <span class="article__small-code">const name = 'value'</span>
            </p>
            <p class="article__subsection__text">
              Aby wykorzystać zmienną w ramach jakiegoś stringa należy opakować
              treść w ` (znaczek pod ~), a wewnątrz polecenia podać
              $(nazwazmiennej), np:<br />
              <span class="article__small-code"
                >SomeComand(`Some string $(some-variable)`)</span
              >
            </p>
          </section>
          <section>
            <h4 class="article__subsection__heading">Komunikaty w JS</h4>
            <p class="article__subsection__text">
              Pierwsze instrukcje poznane w ramach szkolenia to alert oraz
              console log
            </p>
            <p class="article__subsection__text">
              Alert (powiadomienie-popup w przeglądarce) wywołujemy tak:<br />
              <span class="article__small-code">alert('value')</span>
            </p>
            <p class="article__subsection__text">
              Console log (komunikat widoczny w konsoli dostępnej pod F12)
              wywołujemy tak: <br />
              <span class="article__small-code">console.log('value')</span>
            </p>
          </section>
        </article>
      </section>

      <!-- START OF WEEEK -->
      <section id="week4" class="week anchorOffset">
        <h2 class="week__heading">Tydzień 4:</h2>
        <article class="article">
          <h3 class="article__heading">box-sizing</h3>
          <p class="article__text">
            Raczej przypomnienie niż coś nowego; Domyślnie jak definiujemy
            wymiary jakiegoś elementu to definiujemy rozmiary wyłącznie treści.
            Do ostatecznych wymiarów elementu trzeba dodatkowo dodać padding
            oraz border.
          </p>
          <p class="article__text">
            Można zmodyfikować sposób nadawania width/height (tak, aby ten
            wymiar opisywał treść elementu WRAZ Z paddingiem i borderem poprzez
            zmianę parametru box-sizing:<br />
            <span class="article__small-code">box-sizing: border-box;</span>
          </p>
        </article>

        <article class="article">
          <h3 class="article__heading">position: sticky;</h3>
          <p class="article__text">
            Samo position: sticky; było mi znane już dawno. W ramach kursu
            dowiedziałem się natomiast dwóch rzeczy:
          </p>
          <ul class="list">
            <li class="list__item">
              Parent elementu z ustawionym position: sticky nie może mieć
              ustawionego overflow (albo nie będzie to działać)
            </li>
            <li class="list__item">
              Polecenie "sticky"
              <strong>przykleja elementy WYŁĄCZNIE do końca parenta</strong>
              (czyli jeżeli nadamy to dla jakiejś sekcji, do gdy skończymy
              scrollować sekcję to element się odklei
            </li>
          </ul>
        </article>

        <article class="article">
          <h3 class="article__heading">position: relative/absolute;</h3>
          <p class="article__text">
            Kolejne przypomnienie: position ABSOLUTE ustawia element względem
            najbliższego przodka z parametrem RELATIVE
          </p>
        </article>

        <article class="article">
          <h3 class="article__heading">
            float: left/right oraz clear/overflow
          </h3>
          <p class="article__text">
            Korzystając z polecenia "flow" można sprawić, że element z tym
            parametrem jest opływany przez tekst z określonej strony.
          </p>
          <p class="article__text">
            Istnieje jednak haczyk - w momencie, gdy element opływający jest
            krótszy od elementu opływanego - ten zewnętrzny pojemnyk nie jest
            rozciągany do wysokości elementu z parametrem float.
          </p>
          <p class="article__text">
            Przykład takiej sytuacji: żółty prostokąt po lewej ma ustawione
            float: right. Div w którym się znajduje ma białe tło. Tło nie jest
            rozciągane:
          </p>
          <img
            src="/images/flow.jpg"
            alt="Printscreen with example of flow property problem"
            class="article__image"
          />
          <p class="article__text">
            Rozwiązaniem takiego problemu może być ustawienie parametru clear
            dla jakiegoś obiektu (choćby pustego diva) w tym samym
            kontenerze:<br />
            <span class="article__small-code">clear: left/right</span>
          </p>
          <p class="article__text">
            Inne rozwiązanie to ustawienie OVERFLOW dla kontenera w którym
            element z flow się znajduje<br />
            <span class="article__small-code">overflow: hidden</span><br />
            UWAGA! Przy takim rozwiązaniu, o ile kontener ma z góry narzuconą
            wysokość to element z parametrem FLOW będzie ucinany.
          </p>
        </article>

        <article class="article">
          <h3 class="article__heading">JavaScript - typy</h3>
          <p class="article__text">
            Podobnie jak w pythonie - typów zmiennych w JS nie musimy deklarować
            (są przypisywane automatycznie w zależności od danych)<br />
            Można sprawdzić typ zmiennej przez polecenie <br />
            <span class="article__small-code">typeof NazwaZmiennej</span>
          </p>
        </article>

        <article class="article">
          <h3 class="article__heading">
            JavaScript - przypisanie zmiennej do zmiennej
          </h3>
          <p class="article__text">
            W sytuacji, w której mamy zdefiniowaną zmienną X<br />
            <span class="article__small-code">let x = 10</span>
          </p>
          <p class="article__text">
            I zdefiniujemy nową zmienną Y równą X<br />
            <span class="article__small-code">let y = x</span>
          </p>
          <p class="article__text">
            To do zmiennej Y jest kopiowany wynik zmiennej X. To znaczy obie
            zmienne wskazują ten sam wynik. Y nie wskazuje na X. Dlatego też
            zmiana X nie zmodyfikuje Y. Tzn. po poleceniu:<br />
            <span class="article__small-code">x = 5</span><br />
            wynik Y dalej będzie = 10
          </p>
        </article>

        <article class="article">
          <h3 class="article__heading">
            JavaScript - uzyskanie wyniku jakiegoś elementu na bieżącej stronie
          </h3>
          <p class="article__text">
            W JS można otrzymać cały kod elementu (wraz z wszystkimi jego
            potomkami) poprzez polecenie:<br />
            <span class="article__small-code"
              >document.querySelectir('.nazwaKlasy/#nazwaId/nazwaElementu')</span
            >
          </p>
          <p class="article__text">
            To samo można było osiągnąc w jQuerry poprzez<br />
            <span class="article__small-code">$('.nazwaKlasy')</span>
          </p>
          <p class="article__text">
            Na potrzeby odniesienia się do elementu w ramach JS, przy stosowaniu
            nazw zgodnych z BEM takie klasy powinny mieć modifier --js np:<br />
            <span class="article__small-code">article__header--js</span>
          </p>
          <p class="article__text">
            Możemy nadpisywać zawartość elementu po przechwyceniu selectora<br />
            <span class="article__small-code">
              myTitle = document.querySelector('.title1')<br />
              myTitle.innerHTML = "Salamander Krajza"
            </span>
          </p>
        </article>

        <article class="article">
          <h3 class="article__heading">Różnica między DOM a HTML</h3>
          <p class="article__text">
            HTML mamy w plikach czy w edytorze. Jest to kod który piszemy na
            podstawie którego generowana jest nasza strona. <br />DOM to finalny
            wynik wyświetlany w przeglądarce. Źródło strony (napisane w HTML)
            może być zmodyfikowane np. przez skrypty JS. Dopiero to co widzimy
            finalnie w przeglądarce to DOM
          </p>
        </article>
      </section>

      <!-- START OF WEEEK -->
      <section id="week5" class="week anchorOffset">
        <h2 class="week__heading">Tydzień 5:</h2>
        <article class="article">
          <h3 class="article__heading">Funkcje w JS</h3>
          <section class="article__subsection">
            <h4 class="article__subsection__heading">
              Podstawowy zapis funkcji:
            </h4>
            <img
              class="article__image"
              src="images/w5/function_js.png"
              alt="How create function in JS"
              height="250"
            />
          </section>
          <section class="article__subsection">
            <h4 class="article__subsection__heading">
              Fat arrow functions:
            </h4>
            <img
              class="article__image"
              src="images/w5/function_js_fat_arrow.png"
              alt="How create function in JS (fat arrow method)"
              height="200"
            />
            <p class="article__text">
              Arrow functions są nie mają słowa kluczowego
              <span class="green-text">function</span>, zamiast tego są
              przypisywane do stałych.<br />
              Pierwszy przykład (<span class="green-text">greet</span>) to
              funkcja bezzwrotna, która wyświetla treść w konsoli.<br />
              Druga funkcja (<span class="green-text">calculate</span>) to
              oneliner który zwraca wynik wyrażenia zapisanego po znaku
              <span class="green-text">=></span>
            </p>
          </section>
        </article>
        <article class="article">
          <h3 class="article__heading">
            Obiekty w JS; metody w ramach obiektów
          </h3>
          <img
            class="article__image"
            src="images/w5/obiekt_js.png"
            alt="How create object in JS"
            height="250"
          />
          <ul class="list">
            <li class="list__item">Działają podobnie do klas w pythonie.</li>
            <li class="list__item">
              Podobnie jak tam funkcje w ramach obiektu nazywamy metodami.
            </li>
            <li class="list__item">
              Własności obiektów tworzymy na zasadzie pythonowych słowników (tj
              klucz:wartość)
            </li>
            <li class="list__item">
              Słowa LET/CONST są pomijane, po prostu podajemy nazwę
              zmiennej/funkcji
            </li>
            <li class="list__item">
              Metody tworzymy używając sposobu arrow function.
            </li>
            <li class="list__item">
              Do elementow wewnątrz obiektu odwołujemy się jak w VBA/PYTHONIE -
              przez kropkę tj np.
              <span class="article__small-code">deathStar.levels</span>
            </li>
          </ul>
          <section class="article__subsection">
            <h4 class="article__subsection__heading">
              Alternatywny sposób na tworzenie metod w obiekcie (poza arrow
              function)
            </h4>
            <div class="article__code">
              <p>var person = {</p>
              <p class="tab">firstName: "John",</p>
              <p class="tab">lastName : "Doe",</p>
              <p class="tab">id : 5566,</p>
              <p class="tab">fullName : function() {</p>
              <p class="doubletab">
                return this.firstName + " " + this.lastName;
              </p>
              <p class="tab">}</p>
              <p>};</p>
            </div>
          </section>
          <section class="article__subsection">
            <h4 class="article__subsection__heading">
              Tworzenie obiektu w obiekcie
            </h4>
            <div class="article__code">
              <p>parentObject{</p>
              <p class="tab">firstName: "John",</p>
              <p class="tab">lastName : "Doe",</p>
              <p class="tab">childObject : {</p>
              <p class="doubletab">
                childObectSomething: "Example";
              </p>
              <p class="tab">}</p>
              <p>};</p>
            </div>
          </section>
          <section class="article__subsection">
            <h4 class="article__subsection__heading">
              Odwołania do metod (normalnie + bracket notation)
            </h4>
            <div class="article__code">
              <p>const testObject = {</p>
              <p class="tab">firstName:"Piotr",</p>
              <p class="tab">fullname: function(surname) {</p>
              <p class="doubletab">return `${this.firstName} ${surname}`</p>
              <p class="tab">}</p>
              <p>};</p>
              <p>console.log(testObject.fullname('Mr.'));</p>
              <p>console.log(testObject['fullname']('Mr.'))</p>
            </div>
          </section>
        </article>
        <article class="article">
          <h3 class="article__heading">Mutowalność i niemutowalność w JS</h3>
          <p class="article__text">
            Tutaj również jest dużo analogi do pythona. Wszystkie typy proste (a
            więc stringi/liczby) stanowią wskazania na istniejące we
            wszechświecie wartości miejsca, które nie są nadpisywane. Zmiana
            wartości prostej ZAWSZE będzie stanowiła przepięcie do innego
            miejsca we wszechświecie wartości. Dlatego też jeżeli dwie zmienne
            mają jednakową wartość (wskazują na to samo miejsce) to aktualizacja
            jednej z nich odpina (tą jedną) od tej wartości i przypina do innej.
            Wartość drugiej zmiennej pozostaje bez zmian.
          </p>
          <section class="article__subsection">
            <h4 class="article__subsection__heading">
              Przypisania do obiektów
            </h4>
            <p class="article__text">
              Obiektu skolei zachowują się przeciwnie. Każdy obiekt jest nowym
              tworem w przestrzeni wartości. W momencie kiedy wiele zmiennych ma
              przypisany ten sam obiekt to zmiana elementów tego obiektu z
              poziomu dowolnej zmiennej wpływa na wszystkie wskazania (to jest
              pojedynczy obiekt, poszczególne zmiennie nie mają niezależnych
              opii)
            </p>
            <img
              class="article__image"
              src="images/w5/humanOne=humanTwo.png"
              alt="How variables and values are connected"
              height="250"
            />
          </section>
          <section class="article__subsection">
            <h4 class="article__subsection__heading">
              Przypisania do wartości/obiektów wewnątrz obiektów
            </h4>
            <p class="article__text">
              To czy element jest wewnątrz innego obiektu nie ma znaczenia,
              zasada jest dokłądnie taka sama - jeżeli przypisujemy do wartości
              prostej (string/liczba) to przypisujemy do konkretnego miejsca w
              przestrzeni i zmiany jednego wystąpienia danej wartości (jednej
              zmiennej) nie będą wpływać na inne.
            </p>
            <p class="article__text">
              Np. jeżeli w ramach obiektu person jest person.Age=36 i ktoś zrobi
              zmienną const test=person.Age a następnie zmieni person.Age albo
              test to drugie nie zostanie zmienione
            </p>
            <p class="article__text">
              Jeżeli w ramach obiektu jest inny obiekt i ktoś przypisze do innej
              zmiennej ten obiekt tj np const zmienna=person.childObject a
              następnie zmieni jakąś własność tego obiektu tj np
              zmienna.name='something' to ta zmiana zajdzie również w obiekcie
              person.childObject
            </p>
          </section>
        </article>
        <article class="article">
          <h3 class="article__heading">Description List</h3>
          <ul class="list">
            <li class="list__item">DL - description list</li>
            <li class="list__item">DT - description title</li>
            <li class="list__item">DD - description details</li>
          </ul>
          <p class="article__text">
            Lista służąca do opisywania jakichś definicji/wskazówek. Może być np
            użyta do stworzenia bestriariusza gdzie w liście mamy
          </p>
          <p class="article__code">
            &lt;dl&gt;<br />
            &lt;dt&gt;Arachnomorf&lt;/dt&gt;<br />
            &lt;dd&gt;Arachnomorf jest padatny na większość wiedźmińskich
            znaków&lt;/dd&gt;<br />
            &lt;dl&gt;
          </p>
        </article>
        <article class="article">
          <h3 class="article__heading">Tabele</h3>
          <ul class="list">
            <li class="list__item">&lt;tr&gt; - table row</li>
            <li class="list__item">
              &lt;td&gt; - komórka tabeli (Table data/cell)
            </li>
            <li class="list__item">&lt;thead&gt; - table header (nagłówek)</li>
            <li class="list__item">&lt;th&gt; - komórka w nagłówku</li>
            <li class="list__item">&lt;tbody&gt; - ciało tabeli</li>
            <li class="list__item">
              &lt;caption&gt; - rzadko używany, opis tabeli (przed danymi,
              wygląda jak nagłówek)
            </li>
          </ul>
          <p class="article__text">
            Tabel należy używać tylko do przechowywaniu danych które normalnie
            opakowuje się w tabele (jakieś liczby, statystyki itd). NIGDY do
            budowania layoutów
          </p>
        </article>
        <article class="article">
          <h3 class="article__heading">Flex</h3>
          <ul class="list">
            <li class="list__item">
              Własność
              <strong class="article__small-code article__small-code--block"
                >display:flex</strong
              >
              nadajemy kontenerowi zawierającemu układane elementy
            </li>
            <li class="list__item">
              Flex pracuje w dwóch osiach: pionowej i poziomej
            </li>
            <li class="list__item">
              Przez (ustawiane dla KONTENERA)
              <div class="article__small-code article__small-code--block">
                <strong>flex-direction:</strong>
                row(domyślnie)/column/row-reverse/column-reverse
              </div>
              określamy która oś jest osią podstawową
            </li>
            <li class="list__item">
              Przez (ustawiane dla KONTENERA)
              <div class="article__small-code article__small-code--block">
                <strong>flex-wrap:</strong> nowrap(domyślnie)/wrap/wrap-reverse
              </div>
              określamy co ma się dziać z elementami jeżeli nie będą się
              mieścić.
              <strong>Bez ustawienia flex-wrap elementy są zmniejszane.</strong>
              Z zawijaniem elementy przechodzą do nowych linii.
            </li>
            <li class="list__item">
              (ustawiane dla KONTENERA)
              <div class="article__small-code article__small-code--block">
                <strong>flex-flow:</strong> row nowrap
              </div>
              wersja flex-direction oraz flex-wrap
            </li>
            <li class="list__item">
              Przez (ustawiane dla KONTENERA)
              <div class="article__small-code article__small-code--block">
                <strong>justify-content:</strong>
                flex-start(domyślnie)/flex-end/center/space-between/space-around
              </div>
              - określamy jak mają być rozkładane elementy na głównej osi
              (określanej przez flex-direction)
            </li>
            <li class="list__item">
              Przez (ustawiane dla KONTENERA)
              <div class="article__small-code article__small-code--block">
                <strong>align-conent:</strong> stretch(domyślnie, rozciąga
                elementy na całe wolne
                miejsce)flex-start/flex-end/center/space-between/space-around
              </div>
              - określamy jak mają być rozkładane elementy na osi prostopadłej
              do głównej
            </li>
            <li class="list__item">
              Przez (ustawiane dla KONTENERA)
              <div class="article__small-code article__small-code--block">
                <strong>align-items:</strong> stretch(domyślnie, rozciąga
                elementy na całe wolne
                miejsce)flex-start/flex-end/center/baseline
              </div>
              - określamy jak mają być rozkładane elementy na osi prostopadłej
              do głównej - w przeciwieńśtwie do align-content tutaj zasada tyczy
              się pojedynczych wierszy obiektów flexowych, a nie całości
            </li>
            <li class="list__item">
              O działaniu <strong>baseline</strong> (np. w align-items:baseline)
              można poczytać tu (link nie dotyczył flexboxa ale zasada podobna)
              <a href="http://infoheap.com/css-inline-block-baseline-alignment/"
                >baseline aligment</a
              >
            </li>
            <li class="list__item">
              Przez (ustawiane dla ELEMENTU)
              <div class="article__small-code article__small-code--block">
                <strong>align-self:</strong> stretch(domyślnie, rozciąga
                elementy na całe wolne
                miejsce)stretch/flex-start/flex-end/center/baseline
              </div>
              - określamy jak mają być rozkładane elementy na osi prostopadłej
              do głównej
            </li>
            <li class="list__item">
              Przez (ustawiane dla ELEMENTU)
              <div class="article__small-code article__small-code--block">
                <strong>order:</strong> -5/0(domyślnie)/1/10/...
              </div>
              możemy wpływać na kolejność elementów (domyślna wartość to 0). Im
              mniejsza cyfra tym wcześniej element wystąpi
            </li>
            <li class="list__item">
              Przez (ustawiane dla ELEMENTU)
              <div class="article__small-code article__small-code--block">
                <strong>flex-grow:</strong> 0(domyślnie)/1/2
              </div>
              określamy jak bardzo elementy mogą rosnąć żeby wypełnić przestrzeń
              kiedy strona się powiększa (element pochłania puste przestrzenie
              żeby rosnąć). Jeżeli damy na elementach 1 a na wybranym 2 to ten
              element z 2 weźmie 2x więcej pustego miejsca żeby się rozszerzyć
            </li>
            <li class="list__item">
              Przez (ustawiane dla ELEMENTU)
              <div class="article__small-code article__small-code--block">
                <strong>flex-shrink:</strong> 0/1(domyślnie)/2
              </div>
              określamy jak bardzo elementy mogą kurczyć o ile jest za mało
              miejsca. kiedy ustawimy 0 to elementy nie mogą się skurczyć
              bardziej niz oryginalny rozmiar (zaczną wychodzić poza kontener).
              jeżeli element będzie miał flex-shrink:2 to będzie bardziej
              kurczony od innych (np. możemy zmniejszać bardziej marginesy).
              UWAGA - warto to ustawić dla grafik bo inaczej mogą nie trzymać
              wpisanych z palca (jako width: 123px / height: 123px) wymiarów!
            </li>
            <li class="list__item">
              Przez (ustawiane dla ELEMENTU)
              <div class="article__small-code article__small-code--block">
                <strong>flex-basis:</strong> none(domyślnie)/150px/50%/content
              </div>
              rozmiar bazowy - wysokości/szerokości (w zależności od kierunku
              flexa, bierzemy miejsce z osi zgodnej z kierunkiem we
              flex-direction)
            </li>
            <li class="list__item">
              (ustawiane dla ELEMENTU)
              <div class="article__small-code article__small-code--block">
                <strong>flex:</strong> 0 1 150px (flex-grow, flex-shrink;
                flex-basiss)
              </div>
              wersja flex-grow, flex-shrink oraz flex-basis
            </li>
            <li class="list__item">
              UWAGA - flex działa dziwnie. Np. Jeżeli mamy kontener o szerokości
              300px, grafikę o ustalonych wymiarach 150px na 150px oraz element
              &lt;p&gt; z tekstem o nieustalonym rozmiarze - normalnie &lt;p&gt;
              wziełoby pozostałe 150px i zawijało text. Flex natomiast skurczy
              obrazek (o ile nie ma flex-shrink:0 żeby paragraf miał więcej
              miejsca )
            </li>
            <li class="list__item">
              Do flexboxa czasami przydatne jest zgrupowanie treści (która ma
              być razem a nie w kolumnach obok siebie) w jednego zewnętrznego
              diva
            </li>
          </ul>
          <p class="article__text">
            Jako, że flex jest bardzo rozbudowany warto korzystać z dodatkowych
            materiałów jak:
          </p>
          <ul class="list">
            <li class="list__item">powtórne obejrzenie lekcji</li>
            <li class="list__item">
              <a href="https://yoksel.github.io/flex-cheatsheet/">
                podgląd działania poszczególnych własności
              </a>
            </li>
            <li class="list__item">
              <a href="https://flexboxfroggy.com/#pl">
                flexbox forggy czyli gra-ćwiczenie
              </a>
            </li>
          </ul>
        </article>
        <article class="article">
          <h3 class="article__heading">RESET/NORMALIZE</h3>
          <p class="article__text">
            Reset to inaczej wyczyszczenie styli domyślnych przeglądarki. Ma to
            zapobiegać automatycznemy stylowaniu (robieniu wcięć, marginesów,
            pogrubień, podkreśleń itd). Raczej niepraktykowane. Lepszą metodą
            jest normalizacja czyli import pliku normalize.css (dostępnego w
            googlu) który ujednolica bazowe style przeglądarki między różnymi
            przeglądarkami (ten plik nadpisuje style przeglądarkowe więc
            niezalęznie gdzie uruchamiamy stronę wygląda jednakowo)
          </p>
          <p class="article__text">
            Poza plikiem normalize.css warto dodać też ustawienie border-sizing:
            border-box aby ułatwić sobie pracę z wymiarami obiektów (liczenie
            wymiarów które uwzględnai treść+padding+ramkę jest bardziej
            intuicyjne niż samodzielne dodawanie paddingu)
          </p>
          <div class="article__code">
            <p>html {</p>
            <p class="tab">box-sizing: border-box;</p>
            <p>}</p>
            <p>*, *:before, *:after</p>
            <p class="tab">box-sizing: border-box;</p>
            <p>}</p>
          </div>
        </article>
        <article class="article">
          <h3 class="article__heading">BACKGROUND</h3>
          <p class="article__text">
            background-position: center center - określa co ma być widoczne
            jeżeli zmniejszamy okienko przeglądarki (Czy jakaś krawędź ma być
            zawsze widoczna, czy może środek); pierwsze center to w pionie (y),
            drugie w poziomie (x); UWAGA- można podać też % albo odległości
            zamiast top/left/bot/right
          </p>
          <p class="article__text">
            background-repeat: repeat/repeat-x/repeat-y/no-repeat/round/space -
            round powtarza tło ale jednocześnie ma pewne skalowanie wbudowane;
            space - nigdy nie przycina, powtarza
          </p>
          <p class="article__text">
            background-attachment: scroll/fixed/local ; scroll to domyślny
            parametr, scrolluje się ze stroną, fixed przykleja grafikę w miejscu
            (zaczynamy ją zakrywać ale nie przesuwa się względem startu;
          </p>
          <p class="article__text">
            background-attachment: local używamy razem z overflow:hidden i
            sprawia, że tło jakiegoś elementu scrolluje się razem z treścią tego
            elementu (który posiada content większy od niego samego tzn. da się
            go scrollować)
          </p>
          <p class="article__text">
            background-origin: padding-box/border-box/content-box - miejsce od
            którego liczymy background-position
          </p>
          <p class="article__text">
            background-clip: border-box/padding-box/content-box - określa w
            którym miejscu tło powinno być ucinane. domyślnie jest to border-box
            czyli tło jest na cały element. jeżeli przestawimy na content-box to
            tło nie pokryje pustych przestrzeni jakie ma padding a będzie tylko
            i wyłącznie przy samej treści
          </p>
          <p class="article__text">
            background-color: rgba(255, 255, 255, 0.4) - tła z przezroczystością
          </p>
          <p class="article__text">
            background-size: auto/cover/contain/ - 100px 100px - określamy
            ręcznie wymiary; auto - domyślne wymiary grafiki; cover - zawsze
            wypełnia całość elementu (jest rozciągany, może być ucinany żeby
            wypełnić całość) contain - zawsze się mieści cały na ekranie ale
            może zostawiać puste przestrzenie jak proporcje nie pasują
          </p>
          <p class="article__text">
            background: linear-gradient(....) - generowane ze strony
            <a href="https://cssgradient.io/gradient-backgrounds/">
              cssgradient.io
            </a>
          </p>
        </article>
      </section>
    </main>
  </body>
</html>
