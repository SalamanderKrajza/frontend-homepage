<!DOCTYPE html>
<html lang="pl">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Aleksander Krysa - WTF notes</title>
    <link href="styles.css" rel="stylesheet" type="text/css" />
  </head>

  <body class="body">
    <header class="hero" id="hero">
      <span class="hero__title-1">Aleksander Krysa </span>
      <span class="hero__title-2">"błądząc w krainie frontendu" </span>
      <span class="hero__description-1">notatki ze szkolenia </span>
      <a class="hero__link" href="https://cotenfrontend.pl/">
        <span class="hero__description-2">WTF </span>
        <span class="hero__description-3">co ten </span>
        <span class="hero__description-4">frontend</span>
      </a>
    </header>

    <nav class="navigation">
      <div class="navigation__wrapper">
        <a href="index.html" class="navigation__link">O stronie</a>
        <a href="notes.html" class="navigation__link">Notatki z tygodni</a>
        <a href="library.html" class="navigation__link">Przydatne materiały</a>
        <a href="#hero" class="navigation__link">↑ Powrót na górę ↑</a>
      </div>
    </nav>

    <main class="main">
      <header>
        <h1 class="main__heading">Jakich rzeczy udało mi się dowiedzieć?</h1>
      </header>

      <ul class="main-list">
        <li class="main-list__item"><a href="#week1">Tydzień 1</a></li>
        <li class="main-list__item"><a href="#week2">Tydzień 2</a></li>
        <li class="main-list__item"><a href="#week3">Tydzień 3</a></li>
        <li class="main-list__item"><a href="#week4">Tydzień 4</a></li>
        <li class="main-list__item"><a href="#week5">Tydzień 5</a></li>
        <li class="main-list__item"><a href="#week6">Tydzień 6</a></li>
        <li class="main-list__item"><a href="#week7">Tydzień 7</a></li>
        <li class="main-list__item"><a href="#week8">Tydzień 8</a></li>
        <li class="main-list__item"><a href="#week9">Tydzień 9</a></li>
        <li class="main-list__item"><a href="#week10">Tydzień 10</a></li>
        <li class="main-list__item"><a href="#week11">Tydzień 11</a></li>
        <li class="main-list__item"><a href="#week12">Tydzień 12</a></li>
        <li class="main-list__item"><a href="#week13">Tydzień 13</a></li>
      </ul>

      <!-- START OF WEEEK -->
      <section id="week1" class="week anchorOffset">
        <h2 class="week__heading">Tydzień 1:</h2>
        <article class="article">
          <h3 class="article__heading">Absolutnie niczego</h3>
          <p class="article__text">
            Choć to raczej nic dziwnego, z racji, że był to tydzień czysto
            organizacyjny.
          </p>
        </article>
      </section>

      <!-- START OF WEEEK -->
      <section id="week2" class="week anchorOffset">
        <h2 class="week__heading">Tydzień 2:</h2>
        <article class="article">
          <h3 class="article__heading">
            Znaczniki &lt;main&gt;&lt;section&gt;&lt;article&gt;
          </h3>
          <p class="article__text">
            Kiedy tworzyłem swoje pierwsze strony nie używałem ich. Miałem
            okazję je później poznać, ale dopiero wyrabiam nawyk ich używania.
          </p>
          <ul class="list">
            <li class="list__item">
              Artykuł powinien opakowywać taką treść, która wykopiowana ze
              strony sama w sobie (bez niczego zzewnątrz) powinna być
              pojedynczą, zrozumiałą i samodzielną treścią
            </li>
            <li class="list__item">
              Sekcja może zawierać albo wiele artykułów, albo być wydzieloną
              częścią artykułu. Nie musi być zrozumiała samodzielnie. Służy
              raczej do grupowania treści
            </li>
            <li class="list__item">
              Zarówno sekcje i artykuły powinny zaczynać się od nagłówków
            </li>
            <li class="list__item">
              Poziom nagłówka powinien odpowiadać poziomowi zagnieżdżenia
              (liczymy tylko semantyczne znaczniki section/article, divy nic nie
              zmieniają)
            </li>
            <li class="list__item">
              Poza znacznikami MAIN raczej nie powinniśmy mieć sekcji ani
              artykułów oraz znaczników Hx
            </li>
          </ul>
        </article>

        <article class="article">
          <h3 class="article__heading">Validator kodu</h3>
          <p class="article__text">
            Dostępnego pod
            <a href="https://validator.w3.org/nu/#textarea">tym adresem</a>
            validatora kodu nie używałem ani nie widziałem wcześniej. Wydaje się
            fajnym rozwiązaniem.
          </p>
        </article>

        <article class="article">
          <h3 class="article__heading">
            Kończenie szkieletu strony przez ! + TAB
          </h3>
          <p class="article__text">
            Wcześniej nie używałem VSC do pisania stron więc nie znam jeszcze
            wszystkich jego funkcjonalności. Szkielet strony to fajne
            rozwiązanie, choć z racji, że wcześniej używałem VSC do tworzenia
            projektów w django, wymagał ręcznego przestawienia "Language mode"
            na HTML żeby dało się tego użyć.
          </p>
        </article>

        <article class="article article--red">
          <h3 class="article__heading">Dodatkowe pytania:</h3>
          <ul class="list">
            <li class="list__item">
              Kiedy używamy znacznika &lt;header&gt; a kiedy nie? Według
              informacji na slajdach, można go użyć zarówno do main, section
              oraz article, jednak w szkoleniu nie został wykorzystany przy
              artykułach. Dlaczego?
              <ul class="list list--green">
                <li class="list__item">
                  Header kiedy mamy bardziej złożony nagłówek niż tylko h1-6
                </li>
              </ul>
            </li>
            <li class="list__item">
              Jaka jest poprawna forma wypisywania tagów HTML jako kodu? Tag
              "XMP" którego użyłem? Zastąpienie &lt; przez &amp;lt; oraz &gt;
              przez &amp;gt;? Jeszcze coś innego?
              <ul class="list list--green">
                <li class="list__item">"xmp to prehistoria :)"</li>
                <li class="list__item">
                  najlepiej używać &amp;lt; i tympodobnych. Dla wygody można
                  użyć
                  <a href="https://mothereff.in/html-entities">konwertera</a>
                  lub
                  <a
                    href="https://marketplace.visualstudio.com/items?itemName=christopherstyles.html-entities"
                    >wtyczki</a
                  >
                  <br />
                </li>
              </ul>
            </li>
          </ul>
        </article>
      </section>

      <!-- START OF WEEEK -->
      <section id="week3" class="week anchorOffset">
        <h2 class="week__heading">Tydzień 3:</h2>
        <article class="article">
          <h3 class="article__heading">Kanban & Trello</h3>
          <p class="article__text">
            Miałem wcześniej do czynienia z tym narzędziem pod kątem organizacji
            zadań długoterminowo.<br />
            Pierwszy raz używam go do monitorowania postępów w małych zadaniach.
          </p>
        </article>

        <article class="article">
          <h3 class="article__heading">
            &lt;b&gt; vs &lt;strong&gt; vs &lt;i&gt; vs &lt;em&gt;
          </h3>
          <p class="article__text">
            Do tej pory moja wiedza kończyłą się na "oba pogrubiają" oraz "oba
            pochylają". Dopiero w trakcie szkolenia (w dużej części nastawionego
            na semantykę) poznałem różnicę tj:<br />
          </p>
          <ul class="list list--green">
            <li class="list__item">
              &lt;b&gt; oraz &lt;i&gt; to znaczniki wykorzystywane wyłącznie do
              ozdabiania tekstu (zmiany jego wyglądu)
            </li>
            <li class="list__item">
              &lt;strong&gt; oraz &lt;em&gt; to znaczniki semantyczne, strong
              podkreśla istotność wyrażenia, em sugeruje, że zwrot może być
              metaforą/ironią.
            </li>
          </ul>
        </article>

        <article class="article">
          <h3 class="article__heading">Przewijanie do danego elementu</h3>
          <p class="article__text">
            Kiedyś używałem, później przestałem, ostatecznie zapomniałem, a
            teraz mi przypomniano =)<br />
            Aby przewinąć stronę należy w odnośniku wpiać &lt;a
            href=&quot;#ID&quot;&gt;Widoczny Teskt&lt;/a&gt;
          </p>
          <p class="article__text">
            Istniał jednak jeden problem przy używaniu elementów ustawionych
            jako position: sticky. (Po przesunieciu elementy były zasłonięte)
            Jednym z obejść problemu było dodanie:
          </p>
          <div class="article__code">
            [ID]::before {<br />
            &emsp;content: '';<br />
            &emsp;display: block;<br />
            &emsp;height: 50px;<br />
            &emsp;margin-top: -50px;<br />
            &emsp;visibility: hidden;<br />
            }
          </div>
        </article>

        <article class="article">
          <h3 class="article__heading">Specyficzność stylów</h3>
          <p class="article__text">
            Ogólna zasada brzmiąca "style o większej specyficzności mają
            priorytet" oraz "ze stylów o równej specyficzności priorytet ma ten
            dodany później"
          </p>
          <p class="article__text">
            Znałem już wcześniej. I nawet mniej-więcej potrafiłem wyczuć które
            odwołanie jest bardziej specyficzne. Niemniej, są przypadki, które
            interpretowałbym inaczej. W ramach szkolenia dopiero poznałem
            właściwą metodę liczenia tej specyficzności (porównywalna do
            medali).
          </p>
          <img
            class="article__image"
            src="images/specificity.png"
            alt="How calculate specificity?"
            height="150"
          />
        </article>

        <article class="article">
          <h3 class="article__heading">Nadawanie nazw</h3>
          <ul class="list">
            <li class="list__item">
              Zalecana metoda nadawania nazw to używanie pojedynczych słów (a
              gdy to niemożliwe to kebab-case).
            </li>
            <li class="list__item">
              Nazwy klas powinny opisywać funkcje elementu na stronę.
            </li>
            <li class="list__item">
              Nazwy klas powinny być w języku angielskim.
            </li>
          </ul>
        </article>

        <article class="article">
          <h3 class="article__heading">Odwołania do elementów w CSS</h3>
          <ul class="list">
            <li class="list__item">
              Do elementów odwołujemy się podając ich nazwę. Na przykład:
              <ul class="list">
                <li class="list__item">
                  <span class="list__small-code">a {...</span> albo
                  <span class="list__small-code">div {...</span>
                </li>
              </ul>
            </li>
            <li class="list__item">
              Do klas odwołujemy się podając ich nazwę po kropce, Na przykład:
              <ul class="list">
                <li class="list__item">
                  <span class="list__small-code">.moja-klasa {...</span> albo
                  <span class="list__small-code">.small-code {...</span>
                </li>
              </ul>
            </li>
            <li class="list__item">
              Do ID odwołujemy się podając ich nazwę po #. Na przykład:
              <ul class="list">
                <li class="list__item">
                  <span class="list__small-code">#moje-id {...</span> albo
                  <span class="list__small-code">#top {...</span>
                </li>
              </ul>
            </li>
            <li class="list__item">
              Do elementu X będącego potomkiem elementu Y odwołujemy się
              oddzielając nazwy spacją:
              <ul class="list">
                <li class="list__item">
                  <span class="list__small-code">Y X {...</span> albo
                  <span class="list__small-code">main article {...</span>
                </li>
              </ul>
            </li>
            <li class="list__item">
              Do elementu o nazwie X zawierającego klasę Y odwołujemy się pisząc
              nazwę elemntu i klasę po kropce
              <ul class="list">
                <li class="list__item">
                  <span class="list__small-code">X.Y {...</span> albo
                  <span class="list__small-code">article.highlighted {...</span>
                </li>
              </ul>
            </li>
          </ul>
        </article>

        <article class="article">
          <h3 class="article__heading">Pierwszy kontakt z JS</h3>
          <p class="article__text">
            Jako, że wcześniej nie używałem JS to wszystko jest tu dla mnie
            nowe.
          </p>
          <section class="article-subsection">
            <h4 class="article-subsection__heading">Dodawanie skryptów</h4>
            <p class="article-subsection__text">
              Skrypty dodajemy bezpośrednio przez zamknięciem znacznika body
              wewnątrz tagu <br />
              <span class="article-subsection__small-code"
                >&lt;script&gt;&lt;/script&gt;</span
              >
            </p>
            <p class="article-subsection__text">
              Można też odwołać się do zewnętrznego pliku z kodem JS poprzez:
              <br />
              <span class="article-subsection__small-code">
                &lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt;
              </span>
            </p>
          </section>
          <section>
            <h4 class="article-subsection__heading">Zmienne i stałe</h4>
            <p class="article-subsection__text">
              Podobnie jak w każdym języku programowania, występują tu zmienne i
              stałe.
            </p>
            <p class="article-subsection__text">
              Zmienne tworzymy przez polecenie <br />
              <span class="article-subsection__small-code"
                >let name = 'value'</span
              >
            </p>
            <p class="article-subsection__text">
              Stałe tworzymy przez polecenie <br />
              <span class="article-subsection__small-code"
                >const name = 'value'</span
              >
            </p>
            <p class="article-subsection__text">
              Aby wykorzystać zmienną w ramach jakiegoś stringa należy opakować
              treść w ` (znaczek pod ~), a wewnątrz polecenia podać
              $(nazwazmiennej), np:<br />
              <span class="article-subsection__small-code"
                >SomeComand(`Some string $(some-variable)`)</span
              >
            </p>
          </section>
          <section>
            <h4 class="article-subsection__heading">Komunikaty w JS</h4>
            <p class="article-subsection__text">
              Pierwsze instrukcje poznane w ramach szkolenia to alert oraz
              console log
            </p>
            <p class="article-subsection__text">
              Alert (powiadomienie-popup w przeglądarce) wywołujemy tak:<br />
              <span class="article-subsection__small-code">alert('value')</span>
            </p>
            <p class="article-subsection__text">
              Console log (komunikat widoczny w konsoli dostępnej pod F12)
              wywołujemy tak: <br />
              <span class="article-subsection__small-code"
                >console.log('value')</span
              >
            </p>
          </section>
        </article>
      </section>

      <!-- START OF WEEEK -->
      <section id="week4" class="week anchorOffset">
        <h2 class="week__heading">Tydzień 4:</h2>
        <article class="article">
          <h3 class="article__heading">box-sizing</h3>
          <p class="article__text">
            Raczej przypomnienie niż coś nowego; Domyślnie jak definiujemy
            wymiary jakiegoś elementu to definiujemy rozmiary wyłącznie treści.
            Do ostatecznych wymiarów elementu trzeba dodatkowo dodać padding
            oraz border.
          </p>
          <p class="article__text">
            Można zmodyfikować sposób nadawania width/height (tak, aby ten
            wymiar opisywał treść elementu WRAZ Z paddingiem i borderem poprzez
            zmianę parametru box-sizing:<br />
            <span class="article__small-code">box-sizing: border-box;</span>
          </p>
        </article>

        <article class="article">
          <h3 class="article__heading">position: sticky;</h3>
          <p class="article__text">
            Samo position: sticky; było mi znane już dawno. W ramach kursu
            dowiedziałem się natomiast dwóch rzeczy:
          </p>
          <ul class="list">
            <li class="list__item">
              Parent elementu z ustawionym position: sticky nie może mieć
              ustawionego overflow (albo nie będzie to działać)
            </li>
            <li class="list__item">
              Polecenie "sticky"
              <strong>przykleja elementy WYŁĄCZNIE do końca parenta</strong>
              (czyli jeżeli nadamy to dla jakiejś sekcji, do gdy skończymy
              scrollować sekcję to element się odklei
            </li>
          </ul>
        </article>

        <article class="article">
          <h3 class="article__heading">position: relative/absolute;</h3>
          <p class="article__text">
            Kolejne przypomnienie: position ABSOLUTE ustawia element względem
            najbliższego przodka z parametrem RELATIVE
          </p>
        </article>

        <article class="article">
          <h3 class="article__heading">
            float: left/right oraz clear/overflow
          </h3>
          <p class="article__text">
            Korzystając z polecenia "flow" można sprawić, że element z tym
            parametrem jest opływany przez tekst z określonej strony.
          </p>
          <p class="article__text">
            Istnieje jednak haczyk - w momencie, gdy element opływający jest
            krótszy od elementu opływanego - ten zewnętrzny pojemnyk nie jest
            rozciągany do wysokości elementu z parametrem float.
          </p>
          <p class="article__text">
            Przykład takiej sytuacji: żółty prostokąt po lewej ma ustawione
            float: right. Div w którym się znajduje ma białe tło. Tło nie jest
            rozciągane:
          </p>
          <img
            src="/images/flow.jpg"
            alt="Printscreen with example of flow property problem"
            class="article__image"
          />
          <p class="article__text">
            Rozwiązaniem takiego problemu może być ustawienie parametru clear
            dla jakiegoś obiektu (choćby pustego diva) w tym samym
            kontenerze:<br />
            <span class="article__small-code">clear: left/right</span>
          </p>
          <p class="article__text">
            Inne rozwiązanie to ustawienie OVERFLOW dla kontenera w którym
            element z flow się znajduje<br />
            <span class="article__small-code">overflow: hidden</span><br />
            UWAGA! Przy takim rozwiązaniu, o ile kontener ma z góry narzuconą
            wysokość to element z parametrem FLOW będzie ucinany.
          </p>
        </article>

        <article class="article">
          <h3 class="article__heading">JavaScript - typy</h3>
          <p class="article__text">
            Podobnie jak w pythonie - typów zmiennych w JS nie musimy deklarować
            (są przypisywane automatycznie w zależności od danych)<br />
            Można sprawdzić typ zmiennej przez polecenie <br />
            <span class="article__small-code">typeof NazwaZmiennej</span>
          </p>
        </article>

        <article class="article">
          <h3 class="article__heading">
            JavaScript - przypisanie zmiennej do zmiennej
          </h3>
          <p class="article__text">
            W sytuacji, w której mamy zdefiniowaną zmienną X<br />
            <span class="article__small-code">let x = 10</span>
          </p>
          <p class="article__text">
            I zdefiniujemy nową zmienną Y równą X<br />
            <span class="article__small-code">let y = x</span>
          </p>
          <p class="article__text">
            To do zmiennej Y jest kopiowany wynik zmiennej X. To znaczy obie
            zmienne wskazują ten sam wynik. Y nie wskazuje na X. Dlatego też
            zmiana X nie zmodyfikuje Y. Tzn. po poleceniu:<br />
            <span class="article__small-code">x = 5</span><br />
            wynik Y dalej będzie = 10
          </p>
        </article>

        <article class="article">
          <h3 class="article__heading">
            JavaScript - uzyskanie wyniku jakiegoś elementu na bieżącej stronie
          </h3>
          <p class="article__text">
            W JS można otrzymać cały kod elementu (wraz z wszystkimi jego
            potomkami) poprzez polecenie:<br />
            <span class="article__small-code"
              >document.querySelectir('.nazwaKlasy/#nazwaId/nazwaElementu')</span
            >
          </p>
          <p class="article__text">
            To samo można było osiągnąc w jQuerry poprzez<br />
            <span class="article__small-code">$('.nazwaKlasy')</span>
          </p>
          <p class="article__text">
            Na potrzeby odniesienia się do elementu w ramach JS, przy stosowaniu
            nazw zgodnych z BEM takie klasy powinny mieć modifier --js np:<br />
            <span class="article__small-code">article__header--js</span>
          </p>
          <p class="article__text">
            Możemy nadpisywać zawartość elementu po przechwyceniu selectora<br />
            <span class="article__small-code">
              myTitle = document.querySelector('.title1')<br />
              myTitle.innerHTML = "Salamander Krajza"
            </span>
          </p>
        </article>

        <article class="article">
          <h3 class="article__heading">Różnica między DOM a HTML</h3>
          <p class="article__text">
            HTML mamy w plikach czy w edytorze. Jest to kod który piszemy na
            podstawie którego generowana jest nasza strona. <br />DOM to finalny
            wynik wyświetlany w przeglądarce. Źródło strony (napisane w HTML)
            może być zmodyfikowane np. przez skrypty JS. Dopiero to co widzimy
            finalnie w przeglądarce to DOM
          </p>
        </article>
      </section>

      <!-- START OF WEEEK -->
      <section id="week5" class="week anchorOffset">
        <h2 class="week__heading">Tydzień 5:</h2>
        <article class="article">
          <h3 class="article__heading">Funkcje w JS</h3>
          <section class="article-subsection">
            <h4 class="article-subsection__heading">
              Podstawowy zapis funkcji:
            </h4>
            <img
              class="article-subsection__image"
              src="images/w5/function_js.png"
              alt="How create function in JS"
              height="250"
            />
          </section>
          <section class="article-subsection">
            <h4 class="article-subsection__heading">
              Fat arrow functions:
            </h4>
            <img
              class="article-subsection__image"
              src="images/w5/function_js_fat_arrow.png"
              alt="How create function in JS (fat arrow method)"
              height="200"
            />
            <p class="article__text">
              Arrow functions są nie mają słowa kluczowego
              <span class="green-text">function</span>, zamiast tego są
              przypisywane do stałych.<br />
              Pierwszy przykład (<span class="green-text">greet</span>) to
              funkcja bezzwrotna, która wyświetla treść w konsoli.<br />
              Druga funkcja (<span class="green-text">calculate</span>) to
              oneliner który zwraca wynik wyrażenia zapisanego po znaku
              <span class="green-text">=></span>
            </p>
          </section>
        </article>
        <article class="article">
          <h3 class="article__heading">
            Obiekty w JS; metody w ramach obiektów
          </h3>
          <img
            class="article__image"
            src="images/w5/obiekt_js.png"
            alt="How create object in JS"
            height="250"
          />
          <ul class="list">
            <li class="list__item">Działają podobnie do klas w pythonie.</li>
            <li class="list__item">
              Podobnie jak tam funkcje w ramach obiektu nazywamy metodami.
            </li>
            <li class="list__item">
              Własności obiektów tworzymy na zasadzie pythonowych słowników (tj
              klucz:wartość)
            </li>
            <li class="list__item">
              Słowa LET/CONST są pomijane, po prostu podajemy nazwę
              zmiennej/funkcji
            </li>
            <li class="list__item">
              Metody tworzymy używając sposobu arrow function.
            </li>
            <li class="list__item">
              Do elementow wewnątrz obiektu odwołujemy się jak w VBA/PYTHONIE -
              przez kropkę tj np.
              <span class="list__small-code">deathStar.levels</span>
            </li>
          </ul>
          <section class="article-subsection">
            <h4 class="article-subsection__heading">
              Alternatywny sposób na tworzenie metod w obiekcie (poza arrow
              function)
            </h4>
            <div class="article-subsection__code">
              <p>var person = {</p>
              <p class="tab">firstName: "John",</p>
              <p class="tab">lastName : "Doe",</p>
              <p class="tab">id : 5566,</p>
              <p class="tab">fullName : function() {</p>
              <p class="doubletab">
                return this.firstName + " " + this.lastName;
              </p>
              <p class="tab">}</p>
              <p>};</p>
            </div>
          </section>
          <section class="article-subsection">
            <h4 class="article-subsection__heading">
              Tworzenie obiektu w obiekcie
            </h4>
            <div class="article-subsection__code">
              <p>parentObject{</p>
              <p class="tab">firstName: "John",</p>
              <p class="tab">lastName : "Doe",</p>
              <p class="tab">childObject : {</p>
              <p class="doubletab">
                childObectSomething: "Example";
              </p>
              <p class="tab">}</p>
              <p>};</p>
            </div>
          </section>
          <section class="article-subsection">
            <h4 class="article-subsection__heading">
              Odwołania do metod (normalnie + bracket notation)
            </h4>
            <div class="article-subsection__code">
              <p>const testObject = {</p>
              <p class="tab">firstName:"Piotr",</p>
              <p class="tab">fullname: function(surname) {</p>
              <p class="doubletab">return `${this.firstName} ${surname}`</p>
              <p class="tab">}</p>
              <p>};</p>
              <p>console.log(testObject.fullname('Mr.'));</p>
              <p>console.log(testObject['fullname']('Mr.'))</p>
            </div>
          </section>
        </article>
        <article class="article">
          <h3 class="article__heading">Mutowalność i niemutowalność w JS</h3>
          <p class="article__text">
            Tutaj również jest dużo analogi do pythona. Wszystkie typy proste (a
            więc stringi/liczby) stanowią wskazania na istniejące we
            wszechświecie wartości miejsca, które nie są nadpisywane. Zmiana
            wartości prostej ZAWSZE będzie stanowiła przepięcie do innego
            miejsca we wszechświecie wartości. Dlatego też jeżeli dwie zmienne
            mają jednakową wartość (wskazują na to samo miejsce) to aktualizacja
            jednej z nich odpina (tą jedną) od tej wartości i przypina do innej.
            Wartość drugiej zmiennej pozostaje bez zmian.
          </p>
          <section class="article-subsection">
            <h4 class="article-subsection__heading">
              Przypisania do obiektów
            </h4>
            <p class="article-subsection__text">
              Obiektu skolei zachowują się przeciwnie. Każdy obiekt jest nowym
              tworem w przestrzeni wartości. W momencie kiedy wiele zmiennych ma
              przypisany ten sam obiekt to zmiana elementów tego obiektu z
              poziomu dowolnej zmiennej wpływa na wszystkie wskazania (to jest
              pojedynczy obiekt, poszczególne zmiennie nie mają niezależnych
              opii)
            </p>
            <img
              class="article-subsection__image"
              src="images/w5/humanOne=humanTwo.png"
              alt="How variables and values are connected"
              height="250"
            />
          </section>
          <section class="article-subsection">
            <h4 class="article-subsection__heading">
              Przypisania do wartości/obiektów wewnątrz obiektów
            </h4>
            <p class="article-subsection__text">
              To czy element jest wewnątrz innego obiektu nie ma znaczenia,
              zasada jest dokłądnie taka sama - jeżeli przypisujemy do wartości
              prostej (string/liczba) to przypisujemy do konkretnego miejsca w
              przestrzeni i zmiany jednego wystąpienia danej wartości (jednej
              zmiennej) nie będą wpływać na inne.
            </p>
            <p class="article-subsection__text">
              Np. jeżeli w ramach obiektu person jest person.Age=36 i ktoś zrobi
              zmienną const test=person.Age a następnie zmieni person.Age albo
              test to drugie nie zostanie zmienione
            </p>
            <p class="article-subsection__text">
              Jeżeli w ramach obiektu jest inny obiekt i ktoś przypisze do innej
              zmiennej ten obiekt tj np const zmienna=person.childObject a
              następnie zmieni jakąś własność tego obiektu tj np
              zmienna.name='something' to ta zmiana zajdzie również w obiekcie
              person.childObject
            </p>
          </section>
        </article>
        <article class="article">
          <h3 class="article__heading">Description List</h3>
          <ul class="list">
            <li class="list__item">DL - description list</li>
            <li class="list__item">DT - description title</li>
            <li class="list__item">DD - description details</li>
          </ul>
          <p class="article__text">
            Lista służąca do opisywania jakichś definicji/wskazówek. Może być np
            użyta do stworzenia bestriariusza gdzie w liście mamy
          </p>
          <p class="article__code">
            &lt;dl&gt;<br />
            &lt;dt&gt;Arachnomorf&lt;/dt&gt;<br />
            &lt;dd&gt;Arachnomorf jest padatny na większość wiedźmińskich
            znaków&lt;/dd&gt;<br />
            &lt;dl&gt;
          </p>
        </article>
        <article class="article">
          <h3 class="article__heading">Tabele</h3>
          <ul class="list">
            <li class="list__item">&lt;tr&gt; - table row</li>
            <li class="list__item">
              &lt;td&gt; - komórka tabeli (Table data/cell)
            </li>
            <li class="list__item">&lt;thead&gt; - table header (nagłówek)</li>
            <li class="list__item">&lt;th&gt; - komórka w nagłówku</li>
            <li class="list__item">&lt;tbody&gt; - ciało tabeli</li>
            <li class="list__item">
              &lt;caption&gt; - rzadko używany, opis tabeli (przed danymi,
              wygląda jak nagłówek)
            </li>
          </ul>
          <p class="article__text">
            Tabel należy używać tylko do przechowywaniu danych które normalnie
            opakowuje się w tabele (jakieś liczby, statystyki itd). NIGDY do
            budowania layoutów
          </p>
        </article>
        <article class="article">
          <h3 class="article__heading">Flex</h3>
          <ul class="list">
            <li class="list__item">
              Własność
              <strong class="list__small-code list__small-code--block"
                >display:flex</strong
              >
              nadajemy kontenerowi zawierającemu układane elementy
            </li>
            <li class="list__item">
              Flex pracuje w dwóch osiach: pionowej i poziomej
            </li>
            <li class="list__item">
              Przez (ustawiane dla KONTENERA)
              <div class="list__small-code list__small-code--block">
                <strong>flex-direction:</strong>
                row(domyślnie)/column/row-reverse/column-reverse
              </div>
              określamy która oś jest osią podstawową
            </li>
            <li class="list__item">
              Przez (ustawiane dla KONTENERA)
              <div class="list__small-code list__small-code--block">
                <strong>flex-wrap:</strong> nowrap(domyślnie)/wrap/wrap-reverse
              </div>
              określamy co ma się dziać z elementami jeżeli nie będą się
              mieścić.
              <strong>Bez ustawienia flex-wrap elementy są zmniejszane.</strong>
              Z zawijaniem elementy przechodzą do nowych linii.
            </li>
            <li class="list__item">
              (ustawiane dla KONTENERA)
              <div class="list__small-code list__small-code--block">
                <strong>flex-flow:</strong> row nowrap
              </div>
              wersja flex-direction oraz flex-wrap
            </li>
            <li class="list__item">
              Przez (ustawiane dla KONTENERA)
              <div class="list__small-code list__small-code--block">
                <strong>justify-content:</strong>
                flex-start(domyślnie)/flex-end/center/space-between/space-around
              </div>
              - określamy jak mają być rozkładane elementy na głównej osi
              (określanej przez flex-direction)
            </li>
            <li class="list__item">
              Przez (ustawiane dla KONTENERA)
              <div class="list__small-code list__small-code--block">
                <strong>align-conent:</strong> stretch(domyślnie, rozciąga
                elementy na całe wolne
                miejsce)flex-start/flex-end/center/space-between/space-around
              </div>
              - określamy jak mają być rozkładane elementy na osi prostopadłej
              do głównej
            </li>
            <li class="list__item">
              Przez (ustawiane dla KONTENERA)
              <div class="list__small-code list__small-code--block">
                <strong>align-items:</strong> stretch(domyślnie, rozciąga
                elementy na całe wolne
                miejsce)flex-start/flex-end/center/baseline
              </div>
              - określamy jak mają być rozkładane elementy na osi prostopadłej
              do głównej - w przeciwieńśtwie do align-content tutaj zasada tyczy
              się pojedynczych wierszy obiektów flexowych, a nie całości
            </li>
            <li class="list__item">
              O działaniu <strong>baseline</strong> (np. w align-items:baseline)
              można poczytać tu (link nie dotyczył flexboxa ale zasada podobna)
              <a href="http://infoheap.com/css-inline-block-baseline-alignment/"
                >baseline aligment</a
              >
            </li>
            <li class="list__item">
              Przez (ustawiane dla ELEMENTU)
              <div class="list__small-code list__small-code--block">
                <strong>align-self:</strong> stretch(domyślnie, rozciąga
                elementy na całe wolne
                miejsce)stretch/flex-start/flex-end/center/baseline
              </div>
              - określamy jak mają być rozkładane elementy na osi prostopadłej
              do głównej
            </li>
            <li class="list__item">
              Przez (ustawiane dla ELEMENTU)
              <div class="list__small-code list__small-code--block">
                <strong>order:</strong> -5/0(domyślnie)/1/10/...
              </div>
              możemy wpływać na kolejność elementów (domyślna wartość to 0). Im
              mniejsza cyfra tym wcześniej element wystąpi
            </li>
            <li class="list__item">
              Przez (ustawiane dla ELEMENTU)
              <div class="list__small-code list__small-code--block">
                <strong>flex-grow:</strong> 0(domyślnie)/1/2
              </div>
              określamy jak bardzo elementy mogą rosnąć żeby wypełnić przestrzeń
              kiedy strona się powiększa (element pochłania puste przestrzenie
              żeby rosnąć). Jeżeli damy na elementach 1 a na wybranym 2 to ten
              element z 2 weźmie 2x więcej pustego miejsca żeby się rozszerzyć
            </li>
            <li class="list__item">
              Przez (ustawiane dla ELEMENTU)
              <div class="list__small-code list__small-code--block">
                <strong>flex-shrink:</strong> 0/1(domyślnie)/2
              </div>
              określamy jak bardzo elementy mogą kurczyć o ile jest za mało
              miejsca. kiedy ustawimy 0 to elementy nie mogą się skurczyć
              bardziej niz oryginalny rozmiar (zaczną wychodzić poza kontener).
              jeżeli element będzie miał flex-shrink:2 to będzie bardziej
              kurczony od innych (np. możemy zmniejszać bardziej marginesy).
              UWAGA - warto to ustawić dla grafik bo inaczej mogą nie trzymać
              wpisanych z palca (jako width: 123px / height: 123px) wymiarów!
            </li>
            <li class="list__item">
              Przez (ustawiane dla ELEMENTU)
              <div class="list__small-code list__small-code--block">
                <strong>flex-basis:</strong> none(domyślnie)/150px/50%/content
              </div>
              rozmiar bazowy - wysokości/szerokości (w zależności od kierunku
              flexa, bierzemy miejsce z osi zgodnej z kierunkiem we
              flex-direction)
            </li>
            <li class="list__item">
              (ustawiane dla ELEMENTU)
              <div class="list__small-code list__small-code--block">
                <strong>flex:</strong> 0 1 150px (flex-grow, flex-shrink;
                flex-basiss)
              </div>
              wersja flex-grow, flex-shrink oraz flex-basis
            </li>
            <li class="list__item">
              UWAGA - flex działa dziwnie. Np. Jeżeli mamy kontener o szerokości
              300px, grafikę o ustalonych wymiarach 150px na 150px oraz element
              &lt;p&gt; z tekstem o nieustalonym rozmiarze - normalnie &lt;p&gt;
              wziełoby pozostałe 150px i zawijało text. Flex natomiast skurczy
              obrazek (o ile nie ma flex-shrink:0 żeby paragraf miał więcej
              miejsca )
            </li>
            <li class="list__item">
              Do flexboxa czasami przydatne jest zgrupowanie treści (która ma
              być razem a nie w kolumnach obok siebie) w jednego zewnętrznego
              diva
            </li>
          </ul>
          <p class="article__text">
            Jako, że flex jest bardzo rozbudowany warto korzystać z dodatkowych
            materiałów jak:
          </p>
          <ul class="list">
            <li class="list__item">powtórne obejrzenie lekcji</li>
            <li class="list__item">
              <a href="https://yoksel.github.io/flex-cheatsheet/">
                podgląd działania poszczególnych własności
              </a>
            </li>
            <li class="list__item">
              <a href="https://flexboxfroggy.com/#pl">
                flexbox forggy czyli gra-ćwiczenie
              </a>
            </li>
          </ul>
        </article>
        <article class="article">
          <h3 class="article__heading">RESET/NORMALIZE</h3>
          <p class="article__text">
            Reset to inaczej wyczyszczenie styli domyślnych przeglądarki. Ma to
            zapobiegać automatycznemy stylowaniu (robieniu wcięć, marginesów,
            pogrubień, podkreśleń itd). Raczej niepraktykowane. Lepszą metodą
            jest normalizacja czyli import pliku normalize.css (dostępnego w
            googlu) który ujednolica bazowe style przeglądarki między różnymi
            przeglądarkami (ten plik nadpisuje style przeglądarkowe więc
            niezalęznie gdzie uruchamiamy stronę wygląda jednakowo)
          </p>
          <p class="article__text">
            Poza plikiem normalize.css warto dodać też ustawienie border-sizing:
            border-box aby ułatwić sobie pracę z wymiarami obiektów (liczenie
            wymiarów które uwzględnai treść+padding+ramkę jest bardziej
            intuicyjne niż samodzielne dodawanie paddingu)
          </p>
          <div class="article__code">
            <p>html {</p>
            <p class="tab">box-sizing: border-box;</p>
            <p>}</p>
            <p>*, *:before, *:after</p>
            <p class="tab">box-sizing: border-box;</p>
            <p>}</p>
          </div>
        </article>
        <article class="article">
          <h3 class="article__heading">BACKGROUND</h3>
          <p class="article__text">
            background-position: center center - określa co ma być widoczne
            jeżeli zmniejszamy okienko przeglądarki (Czy jakaś krawędź ma być
            zawsze widoczna, czy może środek); pierwsze center to w pionie (y),
            drugie w poziomie (x); UWAGA- można podać też % albo odległości
            zamiast top/left/bot/right
          </p>
          <p class="article__text">
            background-repeat: repeat/repeat-x/repeat-y/no-repeat/round/space -
            round powtarza tło ale jednocześnie ma pewne skalowanie wbudowane;
            space - nigdy nie przycina, powtarza
          </p>
          <p class="article__text">
            background-attachment: scroll/fixed/local ; scroll to domyślny
            parametr, scrolluje się ze stroną, fixed przykleja grafikę w miejscu
            (zaczynamy ją zakrywać ale nie przesuwa się względem startu;
          </p>
          <p class="article__text">
            background-attachment: local używamy razem z overflow:hidden i
            sprawia, że tło jakiegoś elementu scrolluje się razem z treścią tego
            elementu (który posiada content większy od niego samego tzn. da się
            go scrollować)
          </p>
          <p class="article__text">
            background-origin: padding-box/border-box/content-box - miejsce od
            którego liczymy background-position
          </p>
          <p class="article__text">
            background-clip: border-box/padding-box/content-box - określa w
            którym miejscu tło powinno być ucinane. domyślnie jest to border-box
            czyli tło jest na cały element. jeżeli przestawimy na content-box to
            tło nie pokryje pustych przestrzeni jakie ma padding a będzie tylko
            i wyłącznie przy samej treści
          </p>
          <p class="article__text">
            background-color: rgba(255, 255, 255, 0.4) - tła z przezroczystością
          </p>
          <p class="article__text">
            background-size: auto/cover/contain/ - 100px 100px - określamy
            ręcznie wymiary; auto - domyślne wymiary grafiki; cover - zawsze
            wypełnia całość elementu (jest rozciągany, może być ucinany żeby
            wypełnić całość) contain - zawsze się mieści cały na ekranie ale
            może zostawiać puste przestrzenie jak proporcje nie pasują
          </p>
          <p class="article__text">
            background: linear-gradient(....) - generowane ze strony
            <a href="https://cssgradient.io/gradient-backgrounds/">
              cssgradient.io
            </a>
          </p>
        </article>
      </section>

      <!-- START OF WEEEK -->
      <section id="week6" class="week anchorOffset">
        <h2 class="week__heading">Tydzień 6:</h2>
        <article class="article">
          <h3 class="article__heading">Formularze</h3>
          <p class="article__text"></p>
          <ul class="list">
            <li class="list__item">
              Formularze opakowujemy w tag
              <b class="list__small-code list__small-code--block">
                &lt;form&gt;&lt;/form&gt;
              </b>
            </li>
            <li class="list__item">
              Formularz może być wysyłany jedną z dwóch metod
              <div class="list__small-code list__small-code--block">
                &lt;form <b>method=&quot;get/post&quot;</b>&gt;
              </div>
              Metoda <strong>GET</strong> wysyłą formularz za pośrednictwem
              adresu URL (querystinga). Wartości te mogą być zedytowane ręcznie.
              <br />
              Metoda <strong>POST</strong> wysyła formularz w postaci danych
              dołączonych do zapytania i nie można ich edytować w ręcznie.
            </li>
            <li class="list__item">
              Formularz można wysłać pod podany adres
              <div class="list__small-code list__small-code--block">
                &lt;form <b>action=&quot;adres_url&quot;</b>&gt;
              </div>
              Dzięki temu formularze mogą wysyłać dane nie tylko w ramach naszej
              strony/aplikacji, ale również mogą pracować z zewnętrznymi
              aplikacjami/stronami/api. Domyślna wartość action to bieżąca
              strona.
            </li>
            <li class="list__item">
              Formularz można wysłać pod podany adres
              <div class="list__small-code list__small-code--block">
                &lt;form <b>action=&quot;adres_url&quot;</b>&gt;
              </div>
              Dzięki temu formularze mogą wysyłać dane nie tylko w ramach naszej
              strony/aplikacji, ale również mogą pracować z zewnętrznymi
              aplikacjami/stronami/api.
            </li>
            <li class="list__item">
              Dane w formularzu wprowadzane są w ramach inputów
              <div class="list__small-code list__small-code--block">
                &lt;input name=&quot;firstName&quot;
                id=&quot;firstName&quot;&gt;
              </div>
              <b>name="..."</b> określa pod jaką nazwą dostępne będą wprowadzone
              w tym polu dane po tym, jak formularz zostanie wysłany (np. na
              potrzeby JSa czy wprowadzenia czegoś do bazy danych)<br />
              <b>id="..."</b> w przypadku inputów jest stworzony na potrzeby
              labeli - o ile input nie jest wewnąrz tagów label to żeby
              przypisać do niego jakąś labelkę podaje się w ramach atrubytu
              <b>for="..."</b> wartość jaką podano przy inpucie jako ID
            </li>
            <li class="list__item">
              Opisy pól:
              <div class="list__small-code list__small-code--block">
                &lt;label for=&quot;idPola&quot;&gt;Opis-pola&lt;/label&gt;
              </div>
              zdefiniowanie połączenia przez for/id pozwala na lepsze wsparcie
              czytników ekranowych oraz większą wygodę w korzystania dzięki
              temu, że wciśnięcie na labelkę automatycznie aktywuje pole gdzie
              mamy wprowadzać wartość.
            </li>
            <li class="list__item">
              Alternatywny sposób opisu labelki
              <div class="list__small-code list__small-code--block">
                &lt;label&gt;First Name&lt;input
                name=&quot;fistName&quot;&gt;&lt;/label&gt;
              </div>
              Jeżeli opakowujemy input w label to te elementy będą automatycznie
              połączone (nie trzeba używać id/for)
            </li>
            <li class="list__item">
              Według dokumentacji każdą parę input/label powinno się opakować w
              paragraf &lt;p&gt;
              <div class="list__small-code list__small-code--block">
                &lt;p&gt;&lt;label&gt;My input&lt;input
                name=&quot;myinput&quot;&gt;&lt;/label&gt;&lt;/p&gt;
              </div>
              Alternatywnie można użyć diva.
            </li>
            <li class="list__item">
              <strong>Typy inputów</strong>
              https://developer.mozilla.org/pl/docs/Web/HTML/Element/Input
              <div class="list__small-code list__small-code--block">
                &lt;input name=&quot;...&quot;
                type=&quot;text/number/email/tel/password/...&quot; /&gt;
              </div>
              Domyślnym typem inputów jest text, inne typy mogą posiadać jakąś
              wbudowaną forme validacji (np. numer może nie przyjmować liter)
              albo ukrywanie znaków (password)
            </li>
            <li class="list__item">
              <strong>type="radio"</strong>
              <div class="list__small-code list__small-code--block">
                &lt;input name=&quot;group-of-answers&quot;
                type=&quot;radio&quot; value=&quot;myFirstAnswer&quot;&gt;
              </div>
              Wszystkie
              <strong>radiobuttony muszą mieć taką samą nazwę</strong> żeby
              działaly jako grupa (zaznaczneie jednego odznaczało poprzedni).<br />
              Żeby móc odróżnić którą wartość użytkownik zaznaczył
              <strong>koniecznie trzeba podać value="..."</strong> różne dla
              każdej wymionionej opcji; w przeciwnym razie w formularzu zostanie
              przesłane "ON" niezależnie od tego które pole wybrano<br />
              Opis każdego z pól typu radiobutton robimy tak jak poprzednio:
              labelem
            </li>
            <li class="list__item">
              <strong>type="checkbox"</strong>
              <div class="list__small-code list__small-code--block">
                &lt;input name=&quot;group-of-answers&quot;
                type=&quot;checkbox&quot;&gt;
              </div>
              Wszystkie checkboxy powinny mieć taką samą nazwę zróżnicowaną
              numerkiem (żeby było wiadomo który checkbox został zaznaczony)<br />
              Opis każdego z pól typu checkbox robimy tak jak poprzednio:
              labelem
            </li>
            <li class="list__item">
              Pole typu checkbox może być domyślnie zaznaczone jeżeli dopiszemy
              do niego checked
              <div class="list__small-code list__small-code--block">
                &lt;input name=&quot;...&quot; type=&quot;checkbox&quot;
                <b>checked</b>&gt;
              </div>
            </li>
            <li class="list__item">
              Podanie parametru VALUE w checkboxie
              <div class="list__small-code list__small-code--block">
                &lt;input type=&quot;checkbox&quot; name=&quot;rules-1&quot;
                <b>value=&quot;agreed&quot;</b> /&gt;
              </div>
              pozwala na zmianę domyślnej wartości jaka jest wysyłana przy
              zaznaczeniu z "ON" na podaną wartość.
            </li>
            <li class="list__item">
              Typ range
              <div class="list__small-code list__small-code--block">
                &lt;input type=&quot;range&quot; min=&quot;0&quot;
                max=&quot;100&quot; step=&quot;10&quot;&gt;
              </div>
              służy do budowania zakresu - wyświetla się jako suwak<br />
              Wartość elementu input z typem "range" jest niewidoczna na
              stronie/z poziomu html. Można się do niej dobrać JSem jeżeli input
              ma jakąś klasę przez
              <b>document.querySelection('.inputClass').value</b>
            </li>
            <li class="list__item">
              Typ file
              <div class="list__small-code list__small-code--block">
                &lt;form method=&quot;post&quot;
                <b>enctype=&quot;multipart/form-data&quot;</b>&gt;<br />
                &lt;label&gt; &lt;input <b>type=&quot;file&quot;</b>&gt;
                &lt;/label&gt;<br />
                ... <br />
                &lt;/form&gt;
              </div>
              Pozwala na wskazanie pliku do załączenia. <br />
              Żeby załączyć plik poza wybranien typu inputa
              <strong
                >trzeba zdefiniować metodę wysylania formularza jako post oraz
                nadpisać bazowy parametr enctype</strong
              >
            </li>
            <li class="list__item">
              Domyślna wartość enctype to
              <div class="list__small-code list__small-code--block">
                &lt;form
                enctype="application/x-ww-form-urlencoded"&gt;...&lt;/form&gt;
              </div>
              nie trzeba jej podawać o ile nie chcemy jej zmienić (np. aby
              przesłać formularz razem z plikiem)
            </li>
            <li class="list__item">
              SELECT - lista rozwijana z opcjami do wyboru
              <div class="list__small-code list__small-code--block">
                &lt;label&gt;<br />
                &lt;<b>select</b> name=&quot;myoptions&quot;
                id=&quot;myoptions&quot;&gt<br />
                &lt;<b>option</b>
                value=&quot;myoptions-1&quot;&gt;Option1&lt;/option&gt;<br />
                &lt;<b>option</b>
                value=&quot;myoptions-2&quot;&gt;Option2&lt;/option&gt;<br />
                &lt;/<b>select</b>&gt;<br />
                &lt;/label>
              </div>
            </li>
            <li class="list__item">
              TEXTAREA - większe bloki tekstu
              <div class="list__small-code list__small-code--block">
                &lt;label&gt;&lt;textarea&gt;&lt;/textarea&gt;&lt;/label&gt;
              </div>
              textarea nie ma parametru value - żeby wpisać coś na start to
              można to wpisać między
              <b>&lt;textarea&gt;m&oacute;j tekst&lt;/textarea&gt;</b>
            </li>
            <li class="list__item">
              typ submit - przycisk wysyłający formularz
              <div class="list__small-code list__small-code--block">
                &lt;input name=&quot;submit&quot; type=&quot;submit&quot;
                value=&quot;text na przycisku&quot;&gt;
              </div>
            </li>
            <li class="list__item">
              &lt;input <b>required</b>&gt; - określa, że pole musi być
              wypełnione zanim formularz zostanie wysłany
            </li>
            <li class="list__item">
              &lt;input <b>pattern=&quot;[a-zA-Z0-9]+&quot;</b>&gt; - patterny
              określają jaki format mają przyjmować dane wejściowe. Patterny są
              opisywane regexami. Kilka przykładowych patternów:
              <a href="http://html5pattern.com/Names">link</a>
            </li>
            <li class="list__item">
              <b>&lt;input value=&quot;InitialValue&quot;&gt;</b> - to jest
              wartość (nie podpowiedź), jak wyślemy to się ta wartość wyśle
            </li>
            <li class="list__item">
              <b>
                &lt;input placeholder=&quot;Wpisz swoje imi&eogon;&quot;&gt;
              </b>
              - wyszarzony tekst w ramach pola (jak zaczniemy wpisywać to
              znika). Przy wysyłaniu formularza się nie wyśle<br />
              UWAGA - placeholder nie wystarczy do zastąpienia
              &lt;label&gt;&apos;a - bez labelek czytniki ekranowe nie będą w
              stanie odczytać poprawnie formularza
            </li>
            <li class="list__item">
              <b>&lt;fieldset&gt;...&lt;/fieldset&gt;</b> - grupuje pola (np.
              można wydzielić sekcję address gdzie będzie miasto/kraj/ulica
              itd)<br />
              <b>
                &lt;legend&gt;Nag&lstrok;&oacute;wek fieldsetu&lt;/legend&gt;
              </b>
              - opisuje daną grupę pól. Legend trzeba zawrzeć wewnątrz fieldsetu
            </li>
            <li class="list__item">
              Formularze można potestować wysyłając je na adres
              http://dev.cotenfrontend.pl/
            </li>
          </ul>
        </article>
        <article class="article">
          <h3 class="article__heading">GRID</h3>
          <img
            class="article__image"
            src="images/w6/grid-concepts.svg"
            alt="Grid example"
            height="350"
          />
          <p class="article__text">
            GRID podobnie do FLEXa służy do rozmieszczania elementów na stronie.
            Grid jest dobrym sposobem na budowanie layoutu.<br />
            GRID NIE ZASTĘPUJE FLEXBOXA - grid służy do budowania layoutów całej
            strony; FLEXBOX służy do pozycjonowania elementów/centrowania
            jakiejś pojedynczej treści
          </p>
          <ul class="list">
            <li class="list__item">
              NUMERACJA w gridzie zaczyna się od 1 (nie od 0 jak w większości
              programowania)
            </li>
            <li class="list__item">
              GRID LINE - są to linie rozdzielające poszczególne kolumny
            </li>
            <li class="list__item">
              GRID TRACK - jest to konkretna kolumna lub wiersz.
            </li>
            <li class="list__item">
              GRID CELL - pojedyncza "KOMÓRKA" w gridzie (czyli jeden element
              będący bezpośrednim dzieckiem obiektu z parametrem GRID)
            </li>
            <li class="list__item">
              GRID AREA - zdefiniowany obszar zawsze w formacie prostokąta (mogą
              to być kwadrat 2x2, blok 1x3 itd.)
            </li>
            <li class="list__item">
              Własność grid jest nadawana kontenerowi który ma układać swoje
              dzieci.
              <b class="list__small-code list__small-code--block">
                display: grid
              </b>
            </li>
            <li class="list__item">
              Definiowanaie kolumn/wierszy w GRIDZIE
              <div class="list__small-code list__small-code--block">
                <b>grid-template-columns:</b> 100px 300px; <br />
                <b>grid-template-row:</b> 100px 200px;
              </div>
              Podając wymiary i rozdzielając je spacją wydzielamy kolejne
              kolumny/wiersze. Poza pixelami można użyć np. %, 10vw albo 1fr.
              <br />
              Jednostki można mieszać dla poszczególnych kolumn/wierszy.<br />
              Jeżeli treść nie zmieści się w dwóch wierszach to trafia do 3
              wiersza o niezdefiniowanej wysokości (wiersz ten rozciąga się aby
              dopasować do treści)
            </li>
            <li class="list__item">
              1FR to nowa jednostka stworzona na potrzeby GRIDa<br />
              <div class="list__small-code list__small-code--block">
                [podana liczba FR]/[Suma wszystich FR]
              </div>
              jednostka FR to taki ułamek. Dzielimy dostępne miejsca pomiędzy
              wszystkie elementy posiadające fr. <br />
              Zakłądając, że mamy 3 kolumny gdzie ich wymiary to oklejno 1fr 1fr
              2fr - piewrsze dwie będa miały po 1/4 całości, ostatnia 2/4
            </li>
            <li class="list__item">
              <b>FR zawsze liczy na bazie wolnej przestrzeni</b> tj mając:<br />
              stronę o szerokości 1000px; <br />
              grid-template-column: 200px 1fr 1fr<br />
              od 1000px odejmujemy 200 a pozostałe 800px dzielimy na 2fr więc są
              kolumny 200px 400px 400px
            </li>
            <li class="list__item">
              funkcja REPEAT:
              <b class="list__small-code list__small-code--block">
                repeat(4, 1fr)
              </b>
              funkcja CSSowa która wypisuje 1fr 1fr 1fr 1fr można użyć np
              jako<br />
              grid-template-column: (4, 1fr) 200px
            </li>
            <li class="list__item">
              przerwy między kolumnami/wierszami
              <b class="list__small-code list__small-code--block">
                column-gap: 16px; <br />row-gap: 16px;
              </b>
              ustalamy na kontenerze - tworzy przerwy między elementami (ale nie
              od zewnętrznej krawędzi grida) - dzięki temu elementy przylegają
              do skrajnych krawędzi kontenera-rodzica ale między sobą(dziećmi)
              mają odstęp
            </li>
            <li class="list__item">
              MINMAX
              <b class="list__small-code list__small-code--block">
                grid-template-column: 1fr minmax(200px 1fr)
              </b>
              pozwala pozwala zablokować kurczenie się elementu poniżej
              zdefiniowanej wartości.<br />
              W przypadku przykładu powyżej prawa kolumna będzie miała
              maksymalnie połowę miejsca a minimalnie 200px; w przypadku
              zwężania całości poniżej 400px tylko 1 kolumna będzie zwężana
              dalej a prawa zachowa 200px
            </li>
            <li class="list__item">
              <div class="list__small-code list__small-code--block">
                <b>grid-template-areas:</b> &quot;header header&quot;
                &quot;article aside&quot; &quot;footer footer&quot;
              </div>
              opisujemy że w pierwszym wierszu ma być dwa razy header, w drugim
              article i aside, w trzecim dwa razy footer (na dwie kolumny) -
              nazwy podawane w cudzysłowach są definiowane jako własności
              elementów pod atrybutem grid-area<br />
              Chcąc dodac kolumnę której nie definiujemy możemy np nazwać . tj
              "article . aside"
              <img
                class="list__image"
                src="images/w6/desired layout.jpg"
                alt="Layout example"
                height="250"
              />
            </li>
            <li class="list__item">
              <div class="list__small-code list__small-code--block">
                <b>grid-area</b>: &lt;nazwa obszaru&gt;<br />
                albo<br />
                <b>grid-area</b>: &lt;row-start&gt; / &lt;col-start&gt; /
                &lt;row-end&gt; / &lt;col-end&gt;
              </div>
              Własność ustawiana na elementach gridowych - pozwala zdefiniować
              ich rozmiar (lub w przypadku nazwanych obszarów także miejsce w
              jakim się znajdą)
            </li>
            <li class="list__item">
              <div class="list__small-code list__small-code--block">
                <b>grid-column-start:</b> 2;<br />
                <b>grid-column-end:</b> 3;<br />
                <b>grid-row-start:</b> 1; <br />
                <b>grid-row-end:</b> 3
              </div>
              określamy w której kolumnie/wierszu się zaczyna/kończy dany
              element; ELEMENTY MOGĄ NA SIEBIE NCHODZIĆ
            </li>
            <li class="list__item">
              <div class="list__small-code list__small-code--block">
                <b>z-index</b>: 2;
              </div>
              W przypadku elementów które na siebie nachodzą możemy dzięki temu
              określić który ma być na wierzchu
            </li>
            <li class="list__item">
              Kolumny można ponazywać przy edfinicji ich wymiarów a potem
              odnosić się do ich nazw tj np:
              <div class="list__small-code list__small-code--block">
                grid-template-columns: [pierwsza] 1fr [<b>druga</b>] 64px
                [trzecia] 200px; <br />
                grid-column-start: <b>druga</b>;
              </div>
            </li>
            <li class="list__item">
              Zamiast pierwszej i ostatniej kolumny/wiersza można podać pierwszą
              i ilość kolumn/wierszy przez słowo SPAN&nbsp;[LICZBA]
              <div class="list__small-code list__small-code--block">
                grid-column-start: pierwsza; <br />
                grid-coulmn-end: <b>span 2</b>;
              </div>
            </li>
            <li class="list__item">
              SPAN działa równiez w przypadku grid-area
              <div class="list__small-code list__small-code--block">
                grid-area: 1 / pierwsza / 3 / span 2;
              </div>
            </li>
            <li class="list__item">
              Zapis skrócony dla grid-column/row-start/end
              <div class="list__small-code list__small-code--block">
                <b>grid-column:</b> &lt;grid-column-start&gt; /
                &lt;grid-column-end&gt;<br />
                <b>grid-row:</b> &lt;grid-row-start&gt; / &lt;grid-row-end&gt;
              </div>
            </li>
          </ul>
        </article>
        <article class="article">
          <h3 class="article__heading">CSS Media queries</h3>
          <p class="article__text">
            Inaczej dopasowanie stylu strony do konkretnych urządzeń.
          </p>
          <p class="article__text">
            <b>RWD</b> - Responsive Web Design lub "Ratuj Własną Dupę" =)
          </p>
          <p class="article__text">
            <b>@media screen/print/...</b> ← definiujemy na czym ma być
            wyświetlany styl (np. czy to dotyczy ekranów czy wydruku)
          </p>
          <p class="article__text">
            <b>@media min-width/max-width/color/aspect-ratio/orientation/...</b>
            ← inne definicje wytycznych do styli UWAGA - szerokość to szerokość
            przeglądarki (nie ekranu)
          </p>
          <p class="article__text">
            <b>not/and/, </b> ← służą do rozdzielania różnych warunków przy
            media queries<br />
            Przecinek działa jak OR tzn np: @media screen, max-width:300px {...}
            będzie zaaplikowane jeżeli treść wyświetlana jest na ekranie lub
            rozdzielczość jest poniżej 300px
          </p>
          <p class="article__text">
            Po zdefiniowaniu warunku otwieramy jakby nowy plik css. Można w nim
            podmieniać pojedyncze własności (nie trzeba przepisywać tego co jest
            zdefiniowane ogólnie dla wszystkich rozdzielczości)
          </p>
          <p class="article__text">
            <b>@media nie wpływa na specyficzność.</b> To co jest niżej jest
            ważniejsze (dlatego najlepiej @media definiować niżej w stylach
          </p>
        </article>
        <article class="article">
          <h3 class="article__heading">JS - wciśnięcie przycisku</h3>
          <p class="article__text">
            <b>button vs a</b> - button do interakcji na danej podstronie; a do
            nawigacji tj skoczenia gdzies indziej
          </p>
          <p class="article__text">
            <b>element.addEventListener(type, listener [, optrions])</b> - po
            stronie JS (po wygenerowaniu strony) można dopiąć do elementu jakąś
            funkcję. (element pobieramy wcześniej przez
            document.querySelector)<br />
            Przykładowe typy eventów:
            <b>mouseenter, mouseleave, mouseover, click</b>
          </p>
          <p class="article__text">
            <b>button.addEventListener('click', myFunction)</b> ← Przykładowe
            dodanie takiego eventu. UWAGA - przy nazwie funkcji nie ma nawiasów
            (i argumentów)<br />
            chcąc przekazać funkcje z argumentami można ewentualnie stworzyć
            nową funkcję (bezargumentową) która będzie wywoływałą funkcję
            docelową z oczekiwanymi<br />
            <b>
              button.addEventListener("click",
              function(){some_function(someVar);});
            </b>
          </p>
          <p class="article__text">
            Przy tworzeniu eventu można definiować funkcje jako arrowfunction
            <b>
              button.addEventListener('click', () => { console.log('blablabla');
              })
            </b>
          </p>
          <p class="article__text">
            Przy tworzeniu eventów można się odwoływać do zmiennej "e" (i
            podawać ją jako argument funkcji). Np<br />
            <b>button.addEventListener('click', (e) => { console.log(e); } )</b
            ><br />
            "e" zawiera dane o mouse evencie. Np. e.target zwraca nam element
            który został wciśnięty
          </p>
        </article>
        <article class="article">
          <h3 class="article__heading">JS - HAMBURGER</h3>
          <p class="article__text">
            HAMBURGER MENU jest tworzone z wykorzystaniem element.<b
              >classList</b
            ><br />
            classList zawiera metody <b>.add/.remove/.toggle/.contains</b><br />
            toggle - dodaje klasę o ile element jej nie ma lub usuwa o ile klasa
            już istnieje<br />
            contains zwraca true/false w zależności czy element zawiera klasę
          </p>
          <p class="article__text">
            przy metodach element.classList... podając nazwę klasy nie piszemy
            "." (w przeciwieństwie do document.querySelection) tj. odwołujemy
            się przez np.<br />
            element.classList.contains('hidden')
          </p>
        </article>
        <article class="article">
          <h3 class="article__heading">JS - logika</h3>
          <section class="article-subsection">
            <h4 class="article-subsection__heading">
              Operatory porównania w JS
            </h4>
            <p class="article-subsection__text">
              &quot;&gt;, &lt;, &gt;=, &lt;=&quot; jak w innych językach<br />
              &quot;!=&quot; - to znak nierówne (nie &lt;&gt;)<br />
              &quot;==&quot; - porównanie<br />
              &quot;===&quot; - porównanie z uwzględnieniem typów<br />
              &quot;!==&quot; - nierówne z uwzględnieniem typów
            </p>
          </section>
          <section class="article-subsection">
            <h4 class="article-subsection__heading">Łączenia warunków</h4>
            <p class="article-subsection__text">
              (...) && (...) - AND<br />
              (...) || (...) - OR<br />
              !(...) - NOT<br />
            </p>
          </section>
          <section class="article-subsection">
            <h4 class="article-subsection__heading">Budowa IFa</h4>
            <img
              class="article-subsection__image"
              src="images/w6/ifelse.jpg"
              alt="IF structure"
              height="150"
            />
          </section>
          <section class="article-subsection">
            <h4 class="article-subsection__heading">Budowa SWITCHa</h4>
            <img
              class="article-subsection__image"
              src="images/w6/switch.jpg"
              alt="SWITCH structure"
              height="200"
            />
          </section>
          <section class="article-subsection">
            <h4 class="article-subsection__heading">IF - Oneliner</h4>
            <img
              class="article-subsection__image"
              src="images/w6/oneliner-if.jpg"
              alt="IF oneliner structure"
              height="70"
            />
            <p class="article-subsection__text">
              Zapis który przechwytuje wynik powyższego:
              <b>const myresult = (a>b) ? true : false;</b>
            </p>
          </section>
        </article>
      </section>
      <section id="week7" class="week anchorOffset">
        <h2 class="week__heading">Tydzień 7:</h2>
        <article class="article">
          <h3 class="article__heading">Pseudoelementy ::after i ::before</h3>
          <p class="article__text">
            Pseudoelementy pozwalają na tworzenie treśći z poziomu plików
            CSS.<br />
            Kiedyś pseudoelementy zapisywano z użyciem jednego dwukropka,
            obecnie stosuje się dwa (choć oba warianty powinny działać)<br />
            Przykłądowy zapis:<br />
            <span class="article__small-code">
              <b>.moja-klasa::after / .moja-klasa::before</b>
            </span>
          </p>
          <p class="article__text">
            Żeby wpisać jakąś treść do pseudoelementu używamy własności
            "content":<br />
            <span class="article__small-code">
              .moja-klasa::after { <b>content: "Moja treść"</b> }
            </span>
          </p>
          <p class="article__text">
            Treść wygenerowana prezz własność CONTNET nie jest częścią DOM'u -
            to znaczy, że nie można jej zaznaczyć myszką ani skopiować.
          </p>
          <p class="article__text">
            elementy ::before i ::after są pierwszym/ostatnim DZIECKIEM elementu
            do których zostały dopisane. To znaczy, że np. dodajac taki element
            do a::after i dopisując jakąś treść, ta treść również będzie się
            zachowywała jak łącze
          </p>
          <p class="article__text">
            pseudoelementy mogą nie zawierać treści (tekstowej) a być np.
            dekoratorami opisanymi przez inne własności CSSowe (np. jakiś
            kształt o zdefiniowanych wymiarach i kolorze). Mogą być stosowane
            dekoracyjnie (np. jako jakaś kropka przed każdym tytułem artykułu)
          </p>
        </article>
        <article class="article">
          <h3 class="article__heading">
            pseudoklasy :hover/:visited/:focus/...
          </h3>
          <p class="article__text">
            Na ogół są to style które aktywują się kiedy konkretne warunki
            zostaną spełnione. Mają wbydowany mechanizm rozpoznawania czy dane
            okoliczności występują (np. nad elementem znajduje się kursor) i
            wyświetlenia zdefiniowanych w tej stytuacji stylów
          </p>
          <p class="article__text">
            <strong>:focus</strong> - określa element który aktualnie jest
            uzupełniany/zaznaczony (np. w trakcie wpisywania treści w formularz
            dane pole może mieć inne obramowanie)
          </p>
          <p class="article__text">
            <strong>:first-child / :last-child / :nth-child</strong> - w
            przypadku tych pseudoklas działanie może nie być do końca intuicyjne
            - nie narzucamy bowiem stylów dla pierwszego dziecka elementu
            któremu nadamy daną klasę, natomiast nadamy style właśnie temu
            elementomi z klasą :fist-child w sytuacji, gdy to on jest czyimś
            pierwszym dzieckiem.<br />
            Przykładowo, jeżeli będziemy mieli listę artykułów i dla elementu
            .article nadamy :first-child to wtedy te style dostanie artykół
            będący pierwszym dzieckiem danej sekcji
          </p>
          <p class="article__text">
            <strong>:not(selektor)</strong> - warunek który sprawdza czy dany
            element nie zawiera danego selektora. Użyteczne w przypadku, gdyby
            inne selektory (np. :hover) były aplikowane tylko i wyłącznie, kiedy
            dany element nie jest jest np. aktualnie aktywny. Wtedy można dać
            element:not('.active'):hover
          </p>
          <p class="article__text">
            <b>Więcej pseudoelementów</b> - można znaleźć w dokumentacji:
            <a
              href="https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes"
              >link</a
            >
          </p>
        </article>
        <article class="article">
          <h3 class="article__heading">
            node.js - taki JavaScript uruchamiany poza przeglądarką
          </h3>
          <p class="article__text">
            NODE nie ma dostępu do DOM - to znaczy nie może podejrzeć danych
            naszej strony i operować na nich. Nie można z niego wywoływać
            żadnych querySelectorów ani nic takiego.
          </p>
          <p class="article__text">
            Pozwala na wywoływanie skryptów JS z poziomu konsoli (np w celu
            szybkich testów). Można założyć plik np. script.js a w nim polecenia
            (np. console.log('hello node')) a z poziomu terminala potem wywołać
            skrypt przez "node script.js" jak z plikami pythonowymi przez
            "python mypython.py"; dzięki temu nie trzeba stawiać żadnego html'a
            i importować plikó JSowych a potem ich wywurzać alertami żeby
            przetestować jakieś skrypty
          </p>
          <p class="article__text">
            w node można od zera tworzyc rozwiazania serwerowe/backend, a można
            też importować i testować gotowe rozwiązania pobierane i uruchamiane
            z jego poziomu (jak klocki lego!). Na drugim wariancie będziemy się
            skupiać w ramach tego szkolenia.
          </p>
        </article>
        <article class="article">
          <h3 class="article__heading">
            NPM - menadżer paczek do node'a
          </h3>
          <p class="article__text">
            NPM to nie jest skrót od NODE PACKAGE MANAGER chociaż tak naprawdę
            NPM spełnia taką rolę. NPM. służy do ułatwiania procesu dodawania do
            naszego projektu bibliotek/narzędzi<br />
            Jest to repozytorium które zapewnia aktualizacje wersji używanych
            narzędzi.<br />
            Pozwala w mniejszym stopniu polegać na konfiguracji edytora i jego
            dodatków (można np. z jego poziomu uruchamiać live-server strony bez
            pobierania wtyczki do VSC)<br />
            NPM można kojarzyć z takim SKLEPEM PLAY dla frontendowców =)
          </p>
          <p class="article__text">
            Aby móc skorzystać z NPM'a trzeba wywołać "npm init" lub "npm init
            -y" w folderze z naszym projektem.<br />
            wersją z "-y" automatycznie zatwierdza wszystkie pytania
            konfiguracyjne domyślną odpowiedzią (można je później modyfikować z
            poziomu pliku)
          </p>
          <p class="article__text">
            Po zainicjalizowaniu NPM'a należy instalować konkrene paczki które
            nas interesują.
          </p>
          <div class="article__small-code">
            npm install &lt;nazwa_paczki&gt; [--save/--save dev]
          </div>
          <p class="article__text">
            Od NPM 5.0.0 Domyślnym parametrem jest --save (nie trzeba go
            pisać)<br />
            <strong>"--save"</strong> używamy o ile chcemy używać narzędzia w
            przeglądarce (np. normalize.css); uzycie tej właściwości sprawia, że
            dana paczka jest dodawana do zależności (dependencies).<br />
            <strong>"--save dev"</strong> używamy jeżeli narzędzie jest
            potrzebne w czasie developmentu (lokalnie), ale już nie potrzebujemy
            go używać po wypuszczeniu strony. Przykładami może być live-server
            albo korwersja scss na css - używamy ich przy pracy nad stroną ale
            nie ma potrzeby ich udostępniać z projektem
          </p>
          <p class="article__text">
            <strong>npm install (bez podania nazwy paczki)</strong>
            - doinstalowuje wszystkie zdefiniowane wcześniej zależności
            (zdefiniowane np. przez npm install &lt;nazwa_paczki&gt;). Ta
            funkcjonalnosć pozwala udostępniać projekt bez udostępniania
            wszystkich potrzebnych paczek (osoba pobierająca projekt może je
            sobie doinstalować a my nie musimy ich wgrywać na serwer). Ponadto,
            dzięki temu można w nieaktywnych projektach usunąć folder
            node_modules (który potrafi zajmować ponad kilka giga!) a w momencie
            powrotu do projektu po prostu pobrać ponownie zależności jedną
            komendą
          </p>
          <p class="article__text">
            Folderu node_modules nie powinno się commitować (należy dodać go do
            .gitignore)
          </p>
          <p class="article__text">
            Alternatywnym menadżerem paczek dla NPMa jest YARN; oba są podobne w
            funkcjonowaniu i łatwo się nauczyć drugiego po poznaniu pierwszego
          </p>
        </article>
        <article class="article">
          <h3 class="article__heading">
            npm run - czyli zdefiniowane skrypty
          </h3>
          <p class="article__text">
            Wewnątrz pliku package.json (generowanego przy wywołaniu npm init)
            możemy zdefiniować własne skrypty<br />
            skrypty definiujemy metodą key:value gdzie jako klucz podajemy
            polecenie które będzie trzeba podać by wywołać skrypt zdefiniowany
            jako value
          </p>
          <p class="article__text">
            Może być stosowane np. do ustawiania konwersji plików SCSS na CSS
            bez każdorazowego definiowania ścieżek do źródła i plików docelowych
          </p>
          <p class="article__text">
            Wywołujemy przez
            <span class="article__small-code"
              >npm run &lt;nazwa_polecenia&gt;</span
            >
          </p>
          <p class="article__text">
            Treść polecenia jest analogiczna do tego co byśmy wpisywali w
            terminalu. Można tam np. coś pobrać i wywołać npxem (tzn "cow":"npx
            cowsay SIEMA SIEMA")
          </p>
        </article>
        <article class="article">
          <h3 class="article__heading">
            NPX - wywoływanie narzędzia bez instalowania na stałe
          </h3>
          <p class="article__text">
            <span class="article__small-code"
              >npx &lt;nazwa_narzędzia&gt; [parametry]</span
            >
            na przykład:
            <span class="article__small-code"> npx cowsay SIEMA SIEMA</span>
          </p>
          <p class="article__text">
            NPX służy do wywołania narzędzia z zadanymi parametrami bez
            pobierania na stałe (pobiera do folderu tymczasowego, uruchamia,
            kasuje)<br />
            Wykorzystujemy głównie do narzędzi konsolowych.
          </p>
        </article>
        <article class="article">
          <h3 class="article__heading">
            Preprocesor - narzędzie które zmienia własną składnie na kod
            rozumiany przez np. przeglądarkę
          </h3>
          <p class="article__text">
            Do tworzenia styli CSS mamy dwa preprocesory - SASS oraz SCSS. Kod
            pisany w tych językach jest wygodniejszy w obsłudze przez
            programistę ale niezrozumiały przez przeglądarkę (wymaga konwersji
            na czysty kod CSS)<br />
            pliki .scss są dla developera, później są konwertowane do .css dla
            przeglądarki
          </p>
          <p class="article__text">
            SASS vs SCSS - to dwa różne wersje składniowe, można używać jednego
            i drugiego. SCSS jest zbliżony do CSSa np. w kwestii używania
            klamerek {}, SASS pracuje na wcięciach (a więc jest bardziej podobny
            do Pythona).<br />
            Te preprocesory rozszerzają możliwośći plików CSS zachowując
            jednocześnie wszystkie oryginalne polecenia. (Można używać
            wszystkiego co w oryginalnym CSSie)
          </p>
        </article>
        <article class="article">
          <h3 class="article__heading">
            Nowe własności w ramach SCSS
          </h3>
          <p class="article__text">
            <b>$zmienna: wartość;</b>- tak definiujemy zmienne w SASSie<br />
            <b>color: $zmienna</b> - tak używamy zmiennej w SASSie
          </p>
          <p class="article__text">
            <b>@mixin / @include</b>- służa do definiowania/używania funkcji
            zawierającej kilka paarametrów.<br />
            Np. możemy chcieć takim mixinem zaokrąglać rogi definiując:
          </p>
          <div class="article__small-code">
            @mixin <b>borderBackground</b> {
            <div class="tab">border-radius: 10px;</div>
            <div class="tab">background: hotpink;</div>
            }
          </div>
          <p class="article__text">
            Żeby użyć właściwości zdefiniowanych mixinem używamy<br />
            <span class="article__small-code">
              * { @include <b>borderBackground</b> }
            </span>
          </p>
          <p class="article__text">
            Można stworzyć mixin z parametrami
          </p>
          <div class="article__small-code">
            borderBackgroundParameter(<b>$radius, $background</b>) {
            <div class="tab">border-radius: <b>$radius</b>;</div>
            <div class="tab">background: <b>$background</b>;</div>
            }
          </div>
          <p class="article__text">
            Wywołanie mixinu z paramterem<br />
            <span class="article__small-code">
              * { @include borderBackgroundParameter(16, hotpink) }
            </span>
          </p>
          <p class="article__text">
            <b>PARENT SELECTOR - &</b> - używany przy zagnieżdżeniach (dobre do
            BEMA) np:
          </p>
          <div class="article__small-code">
            .about {
            <div class="tab">color: red;</div>
            <div class="tab"><b>&__title</b> {</div>
            <div class="doubletab">font-size: 20;</div>
            <div class="tab">}</div>
            }
          </div>
          <p class="article__text">
            <b>@extend selektor;</b> - dopisane do klasy dorzuca style zawarte w
            podanej klasie NA POCZĄTKU (tzn. jeżeli dopiszemy to do .main { ...
            } nawet na końcu definicji .main to style .font-style będą i tak
            wrzucone na sam początek (a każdy styl definiowany w mainie będzie
            to nadpisywał)
          </p>
          <div class="article__small-code">
            .special-font {
            <div class="tab">@extend .font-style;</div>
            }
          </div>
        </article>
        <article class="article">
          <h3 class="article__heading">
            node-sass - paczka do konwertowania plików scss na css
          </h3>
          <p class="article__text">
            <b>(npm install --save-dev) node-sass</b> - polecenie instalacyjne.
            Instalujemy jak --save-dev ponieważ konwersja plikó następuje
            podczas developmentu strony, nastomiast później przesyłane są pliki
            już przekonwertowane.<br />
            <b>node-sass [options] source/file.scss result/file.css</b> -
            przekonwartowanie pliku podanego jako source i zapisanie go jako
            result<br />
            Z dostępnych opcji najbardziej interesuje nas "-w", tzn:<br />
            <b>node-sass source/file.scss result/file.css -w</b> - Opcja watch
            sprawia, że w momencie wprowadzenia zmian w pliku scss to będzie
            automatycznie generował nowy plik css; żeby wyjść z tego polecenia
            klikamy CTRL+C<br />
            Można zdefiniować te polecenie w naszych skryptach w package.json by
            później nie podawać ścieżki do plików a wywoływać "NPN RUN SASS"
          </p>
        </article>
      </section>
      <section id="week8" class="week anchorOffset">
        <h2 class="week__heading">Tydzień 8:</h2>
        <article class="article">
          <h3 class="article__heading">Importy w CSS oraz JS</h3>
          <section class="article-subsection">
            <h4 class="article-subsection__heading">
              Import całości pliku css(scss) do innego pliku css
            </h4>
            <p class="article-subsection__text">
              Używamy do tego polecenia @import "źródło", np.<br />
              <span class="article-subsection__small-code"
                >@import "modules/week-summary.scss"</span
              >
            </p>
            <p class="article-subsection__text">
              Można stosować z linkami do zewnętrznych plików, np.<br />
              <span class="article-subsection__small-code">
                @import
                https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css
              </span>
            </p>
          </section>
          <section class="article-subsection">
            <h4 class="article-subsection__heading">
              Import między plikami JavaScript
            </h4>
            <p class="article-subsection__text">
              Są dwie metody - CommonJS i ES6 Modules
            </p>
            <p class="article-subsection__text">
              Aby korzystać z modułów trzeba dodać do znacznika script parametr
              type="module" tj: `<br />
              <span class="article-subsection__small-code">
                &lt;script scr=&quot;main.js&quot;
                type=&quot;module&quot;&gt;&lt;/script&gt;&grave;
              </span>
            </p>
            <p class="article-subsection__text">
              [IMPORT ES6] Żeby exportować jakąś funkcję trzeba ją zapisać w
              innym pliku ze słowem kluczowym export przed jej definicją tj np:
              <br />
              <span class="article-subsection__small-code">
                export const hello = (name) => { return ;cześć ${name}!; }
              </span>
            </p>
            <p class="article-subsection__text">
              Import polega na podaniu słowa kluczowego import, nazwy elementów
              które pobieramy, słowa kluczowego from i źródła, na przykład: '<br />
              <span class="article-subsection__small-code">
                import {hello, myname} from './hello.js'
              </span>
            </p>
            <p class="article-subsection__text">
              export/import default - o ile w ramach pliku użyjemy słów
              kluczowych &quot;export default &lt;nazwa&gt;;&quot; to przy
              imporcie nie potrzeba klamerek. np: <br />
              <span class="article-subsection__small-code">
                const myName = 'Aleksander'; <br />
                export default myName;<br /> </span
              ><br />
              <span class="article-subsection__small-code">
                import myNameAsSomeVariable from myname.js
              </span>
            </p>
            <p class="article-subsection__text">
              UWAGA - przy imporcie defaultowym można importować jako inną nazwę
              niż zdefiniowano w ramach źródła!
            </p>
            <p class="article-subsection__text">
              Można importować gotowe moduły (pobierane npmem) przez: <br />
              <span class="article-subsection__small-code">
                import nazwaRzeczy from 'nazwa-modulu' </span
              ><br />
              UWAGA! Możliwe, że do działania wymagany jest webpack!
            </p>
            <p class="article-subsection__text">
              Inna metoda (od defaulta) importowania elementów pod inną nazwą to
              użycie <b>`as`</b> np: <br />
              <span class="article-subsection__small-code">
                import {myAwesomeName as myName} from myname.js
              </span>
            </p>
            <p class="article-subsection__text">
              Możliwy mjest zaimportowanie wszystkich exportów danego pliku
              poprzez:
              <span class="article-subsection__small-code">
                import * as myImports from source.js </span
              ><br />
              Do konkretnych (zaimportowanych) zmiennych/funckcji odwołujemy się
              po kropce ich nazwą tj. np. <br />
              <span class="article-subsection__small-code">
                myImports.hello
              </span>
            </p>
          </section>
        </article>
        <article class="article">
          <h3 class="article__heading">
            WEBPACK - podstawowe narzędzie frontendowca
          </h3>
          <p class="article__text">
            WEBPACK - podstawowe narzędzie frontendowca; może automatyzować
            procesy, ułatwia development, używają go wiodące frameworki i
            biblioteki
          </p>
          <p class="article__text">
            Aby go zainstalować trzeba mieć zainicjalizowany projekt w npm i
            wywołać <br />
            <span class="article__small-code">
              npm install webpack webpack-cli --save-dev
            </span>
          </p>
          <p class="article__text">
            Dokumentacja webpacka jest (wraz z opisem uruchamiania) dostępna
            tutaj:
            <a href="https://webpack.js.org/guides/getting-started/">
              dokumentacja
            </a>
          </p>
          <p class="article__text">
            Webpack nie ma pliku konfiguracyjnego, ma jakieś domyślne ścieżki.
            Wywołanie webpacka robi się przez <br />
            <span class="article__small-code"> npx webpack </span><br />
            To polecenie zwróci błędny (informacje, że potrzebuje pliku
            src/index.js oraz pliku index.html)<br />
            Po stworzeniu tych plików można wywołać polecenie ponownie - wtedy
            webpack przygotuje plik `dist/main.js` - mało czytelny (dla
            człowieka) plik wygenerowany z naszych skryptów do udostępnienia na
            stronie.
          </p>
          <p class="article__text">
            Mając webpack można importować paczki/moduły w ramach JS prez:<br />
            <span class="article__small-code">
              import nazwaImportu from 'nazwaPaczki/nazwaModułu'
            </span>
            <br />
            Przykładowym użyciem może być<br />
            <span class="article__small-code">
              import moment from 'moment' <br />
              moment().startOf('day').fromNow()
            </span>
            <br />
            webpack ogarnie skąd i jak ma być zaimportowane. Plik stworzony
            ręcznie i nie przepuszczony przez webpacka nie będzie działał
            poprawnie z takim importem
          </p>
          <p class="article__text">
            Weback wygeneruje plik js który będzie w sobie zawierał te
            zaimportowane zależnośći
          </p>
        </article>
        <article class="article">
          <h3 class="article__heading">
            Webpack starter kit
          </h3>
          <p class="article__text">
            WTF WEBPACK STARTER KIT - zawiera serwer lokalny z autoodświeżąniem,
            wsparcie dla scss i sourcemap, minifikacje, babel oraz publikacje na
            github pages
          </p>
          <p class="article__text">
            babel - tłumaczy kod na inne wersje (dla wsparcia starszych
            przeglądarek)
          </p>
          <p class="article__text">
            Używamy wchodząc w link
            <a
              href="https://github.com/maciejkorsan/wtf-webpack-starter/generate"
              >(Kliknij aby przekierować)</a
            ><br />
            https://github.com/maciejkorsan/wtf-webpack-starter/generate<br />
            https://github.com/maciejkorsan/wtf-webpack-starter/ <br />
            a następnie generując z jego pomocą nowe repozytorium (które zawiera
            te wszystkie startowe elementy)
          </p>
          <p class="article__text">
            Uruchomienie live serwera wymaga zainstalowania zależności prezz
            <b>npm install</b> a potem uruchomienie serwera przez
            <b>npm run start</b>
            wynik dostęny pod localhost:8080
          </p>
          <p class="article__text">
            Pracując z webpackiem ścieżki podajemy względem plików źródłowych
            (tak jak z nimi pracujemy) a nie serwerowych; webpack sobie go
            znajdzie i przeniesie
          </p>
          <p class="article__text">
            WEBPACK dodaje do nazw plików hashe żeby przeglądarka nie trzymała
            starych wersji a pobierała zaktualizowane w przypadku jakiś
            modyfikacji
          </p>
          <p class="article__text">
            Aby dodać nowy plik do webpacka (np. nową podstronę .html) -
            edytujemy plik <b>webpack.common.js</b>, kopiujemy jeden z wpisów
            <b>`new HtmlWebpackPlugin { ...`</b> i uzupełniamy tą nową ścieżką
            <br />
            W ranach tego wpisu ustalamy jakie pliki css oraz js są importowane
            do danego htmla (nie trzeba robić już importów wewnątrz samego
            htmla)
          </p>
          <p class="article__text">
            Mając loader scssów wgrany do konfiguracji webpacka można w ramach
            pliku `index.js` zaimportować plik scss a on zostanie
            przekonwartowany do cssa. zeby to zrobić piszemy
            <b>import '../scss/main.scss'</b>
          </p>
          <p class="article__text">
            Żeby zaimportować istniejącą paczkę w npm którą pobrano do
            node_modules można to zrobić prezz <b>@import "~nazwa-paczki"</b> np
            <b>@import "~normalize.css"</b> w ramach pliku `main.scss`. UWAGA
            "~" nie jest przez pomyłkę =)
          </p>
          <p class="article__text">
            SOURCEMAPA pozwala na podejrzenie gdzie jest dana linijka (która
            wykonuje np console.loga lub narzuca styl w csss) w ramach
            ORYGINALNYCH PLIKÓW! Mega wygodne przy pracy z plikami scss gdzie
            bez sourcemapy (a więc webpacka) z inspektora moglibyśmy podejrzeć
            jedynie przekonwertowany plik .css a nie ten plik na którym
            pracowaliśmy w fazie developmentu
          </p>
          <p class="article__text">
            DIST to katalog który jest efektem finalnym pracy z webpackiem. To
            jego udostępniamy (publikujemy) na serwerze
          </p>
          <p class="article__text">
            Pliki w katalogu PUBLIC są kopiowane do dist bez żadnych zmian
            robionych z poziomu webpacka
          </p>
          <p class="article__text">
            Publikacja strony na github pages jest przeprowadzana przez
            polecenie <b>npm run publish</b> które tworzy nam nową gałąź, wrzuca
            tam pliki z DIST, pushuje i udostępnai na github pages
          </p>
        </article>
        <article class="article">
          <h3 class="article__heading">
            ZMIENNE W BAZOWYM CSS (Czy raczej CSS CUSTOM PROPERTIES)
          </h3>
          <p class="article__text">
            definiujemy w ramach elementu <b>:root { ...</b> podając jego nazwę
            po dwóch myślnikach np.<br />
            <span class="article__small-code">
              :root{ --small-padding: 8px; --text-color: yellow; }
            </span>
          </p>
          <p class="article__text">
            Użycie takiej zmiennej wykorzystuje słowo kluczowe VAR tj np. <br />
            <span class="article__small-code">
              h1 { color: var(--text-color);}
            </span>
          </p>
          <p class="article__text">
            Te zmienne (W csss) żyją też w przeglądarce, tj można je modyfikować
            po wyświetleniu strony. Zmienne definiowane jako SCSS są wczytywane
            w momencie konwersji pliku na plik .css i nie można ich aktualizować
            (w przeglądarce są zastępowane przez swoje wartości)
          </p>
          <p class="article__text">
            Nadpisanie takiej zmiennej z poziomu JS:
            <br>
            <span class="article__small-code">
              document.documentElement.style.setProperty('--zmienna', 'wartość')
            </span>
          </p>
          <p class="article__text">
            Użyteczne przy przełączaniu strony np. na darkmode
          </p>
          <p class="article__text">
            Można te zmienne nadpisywać z użyciem @media tj np.<br> 
            <span class="article__small-code">
              @media (min-width: 768px) { :root { --small-padding: 16px } }
            </span>
          </p>
        </article>
      </section>
    </main>
  </body>
</html>
